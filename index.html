<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
      content="width=device-width, height=device-height, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Tactic Tac Toe</title>
  <style>
    :root {
      font-family: Arial, Helvetica, sans-serif;
      background: #000000;
      color: #f7f7f7;
      --tile-size: 110px;
      --tile-gap: 10px;
      --tile-font: 36px;
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000000;
    }

    .app {
      width: min(90vw, 420px);
      padding: 24px;
      border-radius: 18px;
      background: linear-gradient(135deg, #272d3e, #181c28);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }

    h1 {
      margin-top: 0;
      font-size: 32px;
      letter-spacing: 0.06em;
      text-align: center;
      color: #ffffff;
    }

    .status {
      display: block;
      margin: 16px 0;
      padding: 12px;
      text-align: center;
      font-size: 16px;
      color: #cfd9ff;
      background: rgba(15, 22, 38, 0.6);
      border-radius: 8px;
      min-height: 20px;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: var(--tile-gap, 10px);
      grid-auto-rows: var(--tile-size, 110px);
    }

    button.square {
      aspect-ratio: 1 / 1;
      min-width: 0;
      width: 100%;
      height: 100%;
      font-size: var(--tile-font, 36px);
      font-weight: bold;
      color: #f7f7f7;
      background: #0f1626;
      border: 2px solid #2d374f;
      border-radius: 12px;
      cursor: pointer;
      transition: transform 100ms ease, background 100ms ease;
      position: relative;
      overflow: hidden;
    }

    button.square:disabled {
      cursor: default;
    }

    button.square:hover:not(:disabled) {
      transform: translateY(-2px);
      background: #1f2437;
    }

    .square.win {
      background: #2ba84a;
      border-color: #74de7a;
    }

    .square.x-mark {
      color: #4fd4ff;
    }

    .square.o-mark {
      color: #ff5c7d;
    }

    .square.o-mark.pulsate {
      animation: pulsateO 1.2s ease-in-out infinite;
    }

    .square.x-mark.pulsate {
      animation: pulsateX 1.2s ease-in-out infinite;
    }

    .square.blocked.pulsate {
      animation: pulsateHex 1.2s ease-in-out infinite;
    }

    @keyframes pulsateO {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 92, 125, 0.7);
      }
      50% {
        transform: scale(1.08);
        box-shadow: 0 0 12px 4px rgba(255, 92, 125, 0.9);
      }
    }

    @keyframes pulsateX {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(79, 212, 255, 0.7);
      }
      50% {
        transform: scale(1.08);
        box-shadow: 0 0 12px 4px rgba(79, 212, 255, 0.9);
      }
    }

    @keyframes pulsateHex {
      0%, 100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(255, 20, 147, 0.7);
      }
      50% {
        transform: scale(1.08);
        box-shadow: 0 0 12px 4px rgba(255, 20, 147, 0.9);
      }
    }

    .fade-letter {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1em;
      font-weight: inherit;
      line-height: 1;
      color: inherit;
      pointer-events: none;
      animation: letterFade var(--fade-duration, 3000ms) forwards;
    }

    @keyframes letterFade {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    .hover-preview {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-weight: inherit;
      font-size: 1em;
      line-height: 1;
      opacity: 0;
      color: inherit;
      pointer-events: none;
      transition: opacity 0.24s ease;
    }

    .hover-preview.visible {
      opacity: 0.28125;
    }

    .controls {
      margin-top: 22px;
      display: flex;
      justify-content: center;
      gap: 12px;
    }

    .controls button {
      padding: 10px 18px;
      background: #ff3864;
      border: none;
      color: #fff;
      border-radius: 999px;
      font-size: 16px;
      cursor: pointer;
      transition: opacity 120ms ease;
    }

    .controls button:hover {
      opacity: 0.85;
    }

    .score-row {
      margin-top: 18px;
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      font-size: 15px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #ffffff;
      gap: 8px;
      transform: translateY(-5px);
    }

    .score-row .round-status {
      text-align: center;
      color: #ffffff;
      font-size: 16px;
    }

    .score-row .score-label:first-child {
      color: #48cfff;
    }

    .score-row .align-right {
      text-align: right;
      color: #ff5a7c;
    }

    .card-panel {
      background: transparent;
      border: none;
      padding: 0;
      margin-top: 8px;
    }

    .card-panel.selectable {
      border: none;
      box-shadow: none;
    }

    .card-panel h2 {
      margin: 0;
      font-size: 13px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #9da6c0;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 4px;
      margin: 0;
    }

    .card {
      border-radius: 12px;
      padding: 14px;
      background: #11182a;
      border: 1px solid rgba(255, 255, 255, 0.12);
      min-height: 110px;
      cursor: pointer;
      transition: transform 0.15s ease, border 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
    }

    .card:hover {
      transform: translateY(-3px);
      border-color: #ff3864;
    }

    .card.selected {
      border-color: #33c8ff;
      box-shadow: 0 0 12px rgba(51, 200, 255, 0.5);
    }

    .card-panel .card {
      background: rgba(7, 34, 48, 0.95);
      border-color: rgba(64, 216, 255, 0.35);
    }

    .card-panel.selectable .card {
      border-color: rgba(64, 216, 255, 0.35);
      box-shadow: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .card-panel.selectable .card.glow-active {
      border-color: #00d4ff;
      box-shadow: 0 0 8px rgba(0, 212, 255, 0.6);
    }

    .card-panel.selectable .card.glow-active:hover {
      border-color: #00d4ff;
      background: rgba(9, 43, 60, 0.95);
      box-shadow: 0 0 15px rgba(0, 212, 255, 1);
    }

    .card-panel .card.selected {
      background: rgba(11, 51, 72, 0.95);
      border-color: #33c8ff;
      box-shadow: 0 0 12px rgba(51, 200, 255, 0.5);
    }

    .card.fade-in .card-title,
    .card.fade-in .card-text {
      opacity: 0;
      animation: textFadeIn 0.26s ease forwards;
    }

    .card.fade-out .card-title,
    .card.fade-out .card-text {
      animation: textFadeOut 0.35s ease forwards;
    }

    @keyframes textFadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    @keyframes textFadeOut {
      from {
        opacity: 1;
      }
      to {
        opacity: 0;
      }
    }

    .card-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(4, 7, 15, 0.86);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 20;
    }

    .card-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .card-modal {
      width: min(90vw, 420px);
      max-width: 420px;
    }

    .card-overlay h2 {
      text-align: center;
      margin-bottom: 6px;
      color: #48cfff;
    }

    .card-overlay p {
      margin: 0 0 12px;
      text-align: center;
      color: #cfd9ff;
      font-size: 14px;
      letter-spacing: 0.05em;
    }

    .card.disabled {
      cursor: default;
      opacity: 0.6;
    }

    .card-title {
      margin: 0 0 6px;
      font-size: 17px;
      letter-spacing: 0.05em;
      text-align: center;
    }

    .card-text {
      margin: 0;
      font-size: 14px;
      line-height: 1.4;
      color: #cdd4f0;
      text-align: left;
    }

    .square.blocked {
      background: #3c1f3a;
      border-color: #d14f88;
      color: #f5cedc;
    }

    .square.mystery {
      border-style: dashed;
      border-color: #ff9d00;
      color: #ff9d00;
      font-size: calc(var(--tile-font, 36px) * 0.9);
      text-shadow: 0 0 8px rgba(255, 157, 0, 0.65);
    }

    .square.preview {
      color: #4a4a4a;
      font-weight: 600;
    }

    .square.preview .preview-number {
      opacity: 1;
      transition: opacity 0.75s ease-out;
    }

    .square.preview.fading .preview-number {
      opacity: 0;
    }

    .square.ambush {
      border-color: #ff4545;
      box-shadow: 0 0 10px rgba(255, 69, 69, 0.6);
    }

    .square.ambush.ai-ambush {
      border-color: #2d374f;
      box-shadow: none;
    }

    .square.selected {
      border-color: #33c8ff;
      box-shadow: 0 0 8px rgba(51, 200, 255, 0.5);
    }

    .square.ghost {
      position: relative;
    }

    .square.ghost .ghost-mark {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1em;
      font-weight: bold;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .square.ghost.ghost-turn-0 .ghost-mark,
    .square.ghost.ghost-turn-1 .ghost-mark {
      opacity: 0.33;
    }

    .square.ghost.ghost-turn-2 .ghost-mark {
      opacity: 0.66;
    }

    .square.ghost.ghost-turn-3 .ghost-mark {
      opacity: 1;
    }

    .square.ghost.hidden-ghost .ghost-mark {
      opacity: 0;
    }

    .square.fortress {
      border: 3px solid #ffffff;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
    }

    .win-overlay {
      position: fixed;
      inset: 0;
      background: rgba(13, 15, 27, 0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 220ms ease;
      z-index: 10;
    }

    .win-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .win-overlay.summary-mode {
      pointer-events: none;
    }

    .win-message {
      text-align: center;
      font-size: 36px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .win-message.round-summary {
      font-size: 34px;
      letter-spacing: 0.08em;
      text-transform: none;
    }

    .round-points-line {
      display: block;
      font-size: 42px;
      margin: 12px 0;
    }

    body.shake {
      animation: shake 0.6s ease;
    }

    @keyframes shake {
      0% { transform: translate(0, 0); }
      20% { transform: translate(-4.8px, 2.4px); }
      40% { transform: translate(4.8px, -2.4px); }
      60% { transform: translate(-3.6px, 1.2px); }
      80% { transform: translate(3.6px, -1.2px); }
      100% { transform: translate(0, 0); }
    }

    .ambush-flash {
      position: fixed;
      inset: 0;
      background: rgba(255, 0, 0, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 12;
    }

    .ambush-flash.show {
      opacity: 1;
    }

    .chain-flash {
      position: fixed;
      inset: 0;
      background: rgba(0, 170, 255, 0.35);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 12;
    }

    .chain-flash.show {
      opacity: 1;
    }

    .omfg-flash {
      position: fixed;
      background: rgba(255, 20, 147, 0.6);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease;
      z-index: 12;
      border-radius: 4px;
    }

    .omfg-flash.show {
      opacity: 1;
    }

    .omfg-outline {
      position: fixed;
      border: 3px solid rgba(255, 20, 147, 0.9);
      border-radius: 4px;
      pointer-events: none;
      z-index: 11;
      box-shadow: 0 0 20px rgba(255, 20, 147, 0.6), inset 0 0 20px rgba(255, 20, 147, 0.3);
      transform-origin: center center;
    }

    .ambush-alert {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 64px;
      font-weight: 900;
      color: #ff3b3b;
      letter-spacing: 0.2em;
      text-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 13;
    }

    .ambush-alert.show {
      opacity: 1;
      transform: scale(1);
    }

    .double-ambush-alert {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 72px;
      font-weight: 900;
      color: #ff6b00;
      letter-spacing: 0.25em;
      text-shadow: 0 0 25px rgba(255, 107, 0, 0.9), 0 0 20px rgba(0, 0, 0, 0.8);
      opacity: 0;
      transform: scale(0.8);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 14;
    }

    .double-ambush-alert.show {
      opacity: 1;
      transform: scale(1);
    }

    .chain-alert {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 58px;
      font-weight: 800;
      color: #00c8ff;
      letter-spacing: 0.15em;
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
      opacity: 0;
      transform: scale(0.75);
      transition: opacity 0.2s ease, transform 0.2s ease;
      pointer-events: none;
      z-index: 13;
    }

    .chain-alert.show {
      opacity: 1;
      transform: scale(1);
    }

    .campaign-overlay {
      position: fixed;
      inset: 0;
      background: #000000;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: #ffffff;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 30;
    }

    .campaign-overlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .campaign-message {
      font-size: 48px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .final-score-line {
      font-size: 42px;
      margin: 12px 0;
    }

    .final-status {
      font-size: 54px;
      margin-top: 24px;
    }

    body.ambush-shake {
      animation: ambushShake 0.15s linear infinite;
    }

    @keyframes ambushShake {
      0% { transform: translate(0px, 0px); }
      25% { transform: translate(-2.4px, 1.8px); }
      50% { transform: translate(2.4px, -1.8px); }
      75% { transform: translate(-1.8px, 1.2px); }
      100% { transform: translate(0px, 0px); }
    }

    body.chain-shake {
      animation: chainShake 0.12s linear infinite;
    }

    @keyframes chainShake {
      0% { transform: translate(0, 0); }
      25% { transform: translate(3px, -2.4px); }
      50% { transform: translate(-3px, 1.8px); }
      75% { transform: translate(2.4px, 2.4px); }
      100% { transform: translate(0, 0); }
    }

    #confetti {
      position: fixed;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 9;
    }

    .confetti {
      position: absolute;
      width: 10px;
      height: 18px;
      top: -20px;
      opacity: 0.9;
      border-radius: 2px;
      animation: fall linear forwards;
    }

    @keyframes fall {
      to {
        transform: translate3d(var(--x-move), 110vh, 0) rotate(360deg);
        opacity: 0;
      }
    }

    .toenado-circle {
      position: fixed;
      width: 60px;
      height: 60px;
      border: 3px solid #ffffff;
      border-radius: 50%;
      pointer-events: none;
      z-index: 15;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.8), inset 0 0 10px rgba(255, 255, 255, 0.3);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .toenado-circle.active {
      opacity: 1;
    }

    .toenado-circle.disintegrating {
      opacity: 0;
      transform: scale(1.5);
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .tile-pulled {
      opacity: 0.5;
      transform: scale(0.8);
      transition: opacity 0.2s ease, transform 0.2s ease;
    }

    .tile-attached {
      position: fixed;
      pointer-events: none;
      z-index: 16;
      font-size: 36px;
      font-weight: bold;
      transition: none;
      transform-origin: center center;
    }

    .tile-attached.x-mark {
      color: #4fd4ff;
    }

    .tile-attached.o-mark {
      color: #ff5c7d;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Tactic • Tac • Toe</h1>
    <div id="status" class="status" aria-live="polite"></div>
    <div id="board" class="board"></div>
    <div class="score-row">
      <span class="score-label">X Pts: <strong id="scoreX">0</strong></span>
      <span class="round-status">Round <strong id="roundNumber">1</strong> / 7</span>
      <span class="score-label align-right">O Pts: <strong id="scoreO">0</strong></span>
    </div>
    <div class="card-panel" data-panel-owner="human">
      <div class="card-grid"></div>
    </div>
    <div class="card-panel" data-panel-owner="ai" style="margin-top: 8px;">
      <h2 style="margin: 0 0 8px; font-size: 13px; letter-spacing: 0.1em; text-transform: uppercase; color: #9da6c0;">AI Cards (Debug)</h2>
      <div class="card-grid"></div>
    </div>
  </div>
  <div id="confetti"></div>
  <div id="winOverlay" class="win-overlay">
    <div class="win-message" id="winMessage">Winner!</div>
  </div>
  <div id="ambushFlash" class="ambush-flash"></div>
  <div id="ambushAlert" class="ambush-alert">AMBUSH!!!!</div>
  <div id="doubleAmbushAlert" class="double-ambush-alert">DOUBLE AMBUSH!!!!</div>
  <div id="chainFlash" class="chain-flash"></div>
  <div id="chainAlert" class="chain-alert">CHAIN REACTION!!!!</div>
  <div id="campaignOverlay" class="campaign-overlay">
    <div id="campaignMessage" class="campaign-message"></div>
  </div>

  <script>
    const boardElement = document.getElementById('board');
    const statusElement = document.getElementById('status');
    const scoreElements = {
      X: document.getElementById('scoreX'),
      O: document.getElementById('scoreO')
    };
    const roundElement = document.getElementById('roundNumber');
    const cardPanels = {
      X: {
        panel: document.querySelector('[data-panel-owner="human"]'),
        grid: document.querySelector('[data-panel-owner="human"] .card-grid')
      },
      O: {
        panel: document.querySelector('[data-panel-owner="ai"]'),
        grid: document.querySelector('[data-panel-owner="ai"] .card-grid')
      }
    };

    const BASE_BOARD_SIZE = 3;
    const TOTAL_ROUNDS = 7;
    const HUMAN = 'X';
    const AI = 'O';
    const MYSTERY_CHANCE = 0.5;
    const CARD_FLOW = {
      CONTINUE: 'continue',
      CONSUME: 'consume',
      PENDING: 'pending'
    };
    const scores = { X: 0, O: 0 };
    const cardPool = [
      { id: 'momentum', name: 'Momentum', description: 'Take two turns in a row once per round.', effect: 'extraTurn' },
      { id: 'center-lock', name: 'Center Lock', description: 'Start the run already claiming the center tile.', effect: 'claimCenter' },
      { id: 'grav-anchor', name: 'Grav Anchor', description: 'Lock down the heart of the arena instantly.', effect: 'claimCenter' },
      { id: 'corner-ambush', name: 'Cornering', description: 'Capture a random corner as soon as the board spawns.', effect: 'claimCorner' },
      { id: 'phantom-corners', name: 'Cornered', description: 'Phase into an unseen corner at the start.', effect: 'claimCorner' },
      { id: 'astral-hooks', name: 'Astral Hooks', description: 'Grapple a random corner from turn zero.', effect: 'claimCorner' },
      { id: 'edge-sentinel', name: 'Edgey', description: 'Deploy a sentry on a random edge tile.', effect: 'claimEdge' },
      { id: 'perimeter-warden', name: 'Side Bae', description: 'Patrol gains control of a random edge tile.', effect: 'claimEdge' },
      { id: 'horizon-guards', name: 'Horizon', description: 'A squad auto-claims one border edge.', effect: 'claimEdge' },
      { id: 'waking-storm', name: 'Rando', description: 'Awakens a random tile to carry your mark.', effect: 'claimRandom' },
      { id: 'starlit-bloom', name: 'Starlit Bloom', description: 'A random tile erupts under your control.', effect: 'claimRandom' },
      { id: 'void-rift', name: 'Hexed', description: 'Select a tile to curse. Nobody can use it this round.', effect: 'voidTile' },
      { id: 'purify-sigil', name: 'Purify Sigil', description: 'Cleanses a random cursed tile right now.', effect: 'cleanseTile' },
      { id: 'emma-bloom', name: 'Emma Bloom', description: 'Select an opponent tile; surrounding tiles become yours.', effect: 'emmaBloom' },
      { id: 'switcharoo', name: 'Switcharoo', description: 'Tap any letter to swap it to the other team.', effect: 'switcharoo' },
      { id: 'shatter-rune', name: 'Erasure', description: 'Click an enemy tile to erase it this turn.', effect: 'destroyTile' },
      { id: 'ruin-pulse', name: 'Ruin Pulse', description: 'Charge a pulse that destroys one enemy tile.', effect: 'destroyTile' },
      { id: 'cataclysm-weave', name: 'Cataclysm', description: 'Detonate a tile to erase every connected enemy letter.', effect: 'destroyConnected' },
      { id: 'ambush-snare', name: 'Ambush', description: 'Mark an empty tile. The next foe there loses all connected letters.', effect: 'ambushTrap' },
      { id: 'ghosts', name: 'Ghosts', description: 'Spawn 3 ghosts on random tiles. They materialize after 3 turns.', effect: 'ghosts' },
      { id: 'fortress', name: 'Fortress', description: 'Place a letter; tile becomes permanent this round.', effect: 'fortress' },
      { id: 'omfg', name: 'OMFG', description: 'Select a Hex tile to completely invert the board. Fortresses are immune.', effect: 'omfg' },
      { id: 'toenado', name: 'Toenado', description: 'Select one of your tiles. A tornado sweeps across the board, pulling enemy tiles with it.', effect: 'toenado' }
    ];
    const winOverlay = document.getElementById('winOverlay');
    const winMessage = document.getElementById('winMessage');
    const confettiContainer = document.getElementById('confetti');
    const ambushFlashElement = document.getElementById('ambushFlash');
    const ambushAlertElement = document.getElementById('ambushAlert');
    const doubleAmbushAlertElement = document.getElementById('doubleAmbushAlert');
    const chainFlashElement = document.getElementById('chainFlash');
    const chainAlertElement = document.getElementById('chainAlert');
    const campaignOverlay = document.getElementById('campaignOverlay');
    const campaignMessage = document.getElementById('campaignMessage');

    const playerState = {
      X: createEmptyState(),
      O: createEmptyState()
    };

    let boardSize = BASE_BOARD_SIZE;
    let winCondition = BASE_BOARD_SIZE;
    let board = Array(boardSize * boardSize).fill('');
    let winningLines = generateWinningLines(boardSize, winCondition);
    let currentPlayer = HUMAN;
    let currentRound = 1;
    let gameOver = false;
    let waitingForAI = false;
    let nextRoundTimeout = null;
    let aiChoiceTimeout = null;
    let mysteryTileIndices = [];
    let tileWeights = computeTileWeights(boardSize);
    let roundResolved = false;
    let lastRoundPoints = { X: 0, O: 0 };
    let previewTimeout = null;
    let weightPreviewActive = false;
    let roundSummaryTimeout = null;
    let ambushTraps = new Map();
    let ghostTiles = new Map(); // Map<idx, {owner: player, turns: number}>
    let ambushFlashTimeout = null;
    let ambushAlertTimeout = null;
    let ambushShakeTimeout = null;
    let doubleAmbushAlertTimeout = null;
    let chainFlashTimeout = null;
    let chainAlertTimeout = null;
    let chainShakeTimeout = null;
    let aiCataclysmPending = false;
    let fortressTiles = new Set();
    let aiCardSelectionTimeout = null;
    let aiMoveTimeout = null;

    function randomDelay(min, max) {
      return min + Math.random() * (max - min);
    }
    let campaignOverlayTimeout = null;

    function createEmptyState() {
      return {
        card: null,
        extraTurnAvailable: false,
        extraTurnUsed: false,
        destroyAvailable: false,
        destroyMode: 'single',
        destroyUsed: false,
        awaitingChoice: false,
        choices: [],
        ready: false,
        ambushAvailable: false,
        ambushArming: false,
        emmaBloomArming: false,
        switcharooActive: false,
        hexArming: false,
        fortressArming: false,
        omfgArming: false,
        toenadoArming: false
      };
    }

    function isHumanPlacementPhase() {
      const state = playerState[HUMAN];
      if (!state) return false;
      if (gameOver || waitingForAI || currentPlayer !== HUMAN) return false;
      if (!state.ready || state.awaitingChoice) return false;
      if (state.ambushArming || state.emmaBloomArming || state.switcharooActive || state.hexArming || state.fortressArming || state.omfgArming || state.toenadoArming) return false;
      return true;
    }

    function shouldShowHoverPreview(idx) {
      if (!Number.isInteger(idx)) return false;
      if (!isHumanPlacementPhase()) return false;
      if (board[idx]) return false;
      const tile = boardElement.children[idx];
      if (!tile || tile.disabled) return false;
      if (tile.classList.contains('mystery')) return false;
      return true;
    }

    function showHoverPreview(tile, symbol) {
      if (!tile) return;
      let overlay = tile.querySelector('.hover-preview');
      if (!overlay) {
        overlay = document.createElement('span');
        overlay.className = 'hover-preview';
        tile.appendChild(overlay);
      }
      if (overlay._fadeTimer) {
        clearTimeout(overlay._fadeTimer);
        overlay._fadeTimer = null;
      }
      overlay.textContent = symbol;
      overlay.style.color = symbol === HUMAN ? '#4fd4ff' : '#ff5c7d';
      requestAnimationFrame(() => overlay.classList.add('visible'));
    }

    function hideHoverPreview(tile, immediate = false) {
      if (!tile) return;
      const overlay = tile.querySelector('.hover-preview');
      if (!overlay) return;
      if (overlay._fadeTimer) {
        clearTimeout(overlay._fadeTimer);
        overlay._fadeTimer = null;
      }
      if (immediate) {
        overlay.remove();
        return;
      }
      overlay.classList.remove('visible');
      overlay._fadeTimer = setTimeout(() => {
        overlay.remove();
        overlay._fadeTimer = null;
      }, 240);
    }

    function clearAllHoverPreviews() {
      [...boardElement.children].forEach(tile => hideHoverPreview(tile, true));
    }

    function initBoard() {
      boardElement.innerHTML = '';
      boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 1fr)`;
      for (let idx = 0; idx < board.length; idx++) {
        const btn = document.createElement('button');
        btn.className = 'square';
        btn.dataset.index = idx;
        btn.addEventListener('click', handleMove);
        btn.addEventListener('mouseenter', handleHoverEnter);
        btn.addEventListener('mouseleave', handleHoverLeave);
        boardElement.appendChild(btn);
      }
      updateTileScale();
    }

    function updateTileScale() {
      requestAnimationFrame(() => {
        const width = boardElement.clientWidth || boardElement.offsetWidth || 360;
        const gap = Math.max(4, Math.min(12, 12 - Math.min(boardSize - 3, 6)));
        const tileSize = Math.max(40, Math.floor((width - gap * (boardSize - 1)) / boardSize));
        boardElement.style.setProperty('--tile-gap', `${gap}px`);
        boardElement.style.setProperty('--tile-size', `${tileSize}px`);
        boardElement.style.setProperty('--tile-font', `${Math.max(18, Math.round(tileSize * 0.5))}px`);
      });
    }

    function applyTileMark(tile, symbol) {
      if (!tile) return;
      tile.classList.remove('x-mark', 'o-mark');
      if (symbol === HUMAN) {
        tile.classList.add('x-mark');
      } else if (symbol === AI) {
        tile.classList.add('o-mark');
      }
    }

    function clearTileMark(tile) {
      tile?.classList?.remove('x-mark', 'o-mark');
    }

    function removeTileFadeOverlay(tile) {
      if (!tile) return;
      tile.querySelectorAll('.fade-letter').forEach(el => el.remove());
    }

    function animateLetterFade(tile, symbol, duration = 3000) {
      if (!tile || !(symbol === HUMAN || symbol === AI)) return;
      removeTileFadeOverlay(tile);
      const overlay = document.createElement('span');
      overlay.className = 'fade-letter';
      overlay.style.setProperty('--fade-duration', `${duration}ms`);
      overlay.style.color = symbol === HUMAN ? '#4fd4ff' : '#ff5c7d';
      overlay.textContent = symbol;
      tile.appendChild(overlay);
      setTimeout(() => {
        overlay.remove();
      }, duration);
    }

    function handleMove(event) {
      const idx = Number(event.currentTarget.dataset.index);
      hideHoverPreview(event.currentTarget, true);
      if (gameOver || currentPlayer !== HUMAN || waitingForAI) return;
      if (playerState[HUMAN].awaitingChoice || playerState[AI].awaitingChoice) return;
      if (playerState[HUMAN].ambushArming) {
        attemptAmbushPlacement(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].emmaBloomArming) {
        attemptEmmaBloomSelection(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].hexArming) {
        attemptHexPlacement(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].fortressArming) {
        attemptFortressPlacement(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].omfgArming) {
        attemptOMFGSelection(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].toenadoArming) {
        attemptToenadoSelection(HUMAN, idx);
        return;
      }
      if (playerState[HUMAN].switcharooActive) {
        if (attemptSwitcharooSelection(HUMAN, idx)) {
          return;
        }
      }
      if (!playerState[HUMAN].ready) return;

      if (board[idx] === AI) {
        const destroyResult = useDestroyAbility(HUMAN, idx);
        if (destroyResult === false) {
          // Can't use destroy ability, continue with normal move
        } else {
          // destroyResult is the animation delay (0 for single, 2500 for chain)
          if (destroyResult > 0) {
            // Chain reaction (Cataclysm) - wait for animation, then switch turns
            setTimeout(() => {
              if (!gameOver) {
                processTurnResult(HUMAN);
              }
            }, destroyResult);
          } else {
            // Single tile destroy (Erasure) - player can still place a mark manually
            // Don't switch turns yet, let player place their mark
            // The turn will switch after they place their mark
          }
          return;
        }
      }

      const trapOwner = getAmbushOwner(idx);
      if (trapOwner && trapOwner !== HUMAN) {
        // Opponent's ambush - trigger it
        resolveAmbushSpring(HUMAN, idx, trapOwner);
        return;
      }
      // If placing on own ambush, makeMove will clear it (via checkAndTriggerAmbush)

      if (isMysteryTile(idx) && resolveMysteryTile(HUMAN, idx)) {
        processTurnResult(HUMAN);
        return;
      }

      if (board[idx]) return;
      
      // Check for enemy ghost that hasn't formed yet - can claim it to kill the ghost
      const enemyGhost = ghostTiles.get(idx);
      if (enemyGhost && enemyGhost.owner !== HUMAN && enemyGhost.turns < 3) {
        clearGhostAt(idx);
        statusElement.textContent = 'You claimed the tile and destroyed the enemy ghost!';
        makeMove(idx, HUMAN); // checkAndTriggerAmbush will handle own ambush clearing
        processTurnResult(HUMAN);
        return;
      }
      
      // Clear own ghost if present
      if (isGhostTile(idx)) {
        clearGhostAt(idx);
      }
      makeMove(idx, HUMAN); // checkAndTriggerAmbush will handle own ambush clearing
      processTurnResult(HUMAN);
    }

    function processTurnResult(player) {
      // Advance ghost turns for the opponent's ghosts (they advance when you take a turn)
      const opponent = player === HUMAN ? AI : HUMAN;
      advanceGhostTurns(opponent);
      
      if (checkGameState()) return;
      
      // Check for forced ambush move before switching turns
      const forcedAmbushResult = checkForcedAmbushMove();
      if (forcedAmbushResult === 'activated') {
        // Ambush was activated, resolveAmbushSpring already handled turn switching
        // Just check game state again to see if game ended
        checkGameState();
        return;
      }
      
      if (grantExtraTurn(player)) return;
      switchTurns(player);
    }

    function handleHoverEnter(event) {
      const tile = event.currentTarget;
      const idx = Number(tile.dataset.index);
      if (shouldShowHoverPreview(idx)) {
        showHoverPreview(tile, HUMAN);
      } else {
        hideHoverPreview(tile);
      }
    }

    function handleHoverLeave(event) {
      hideHoverPreview(event.currentTarget);
    }

    function grantExtraTurn(player) {
      const state = playerState[player];
      if (state?.extraTurnAvailable && !state.extraTurnUsed) {
        state.extraTurnUsed = true;
        const cardName = state.card?.name || 'card';
        statusElement.textContent = `${playerLabel(player)} activates ${cardName}! Another turn.`;
        currentPlayer = player;
        startCardDraftFor(player);
        return true;
      }
      return false;
    }

    function switchTurns(player) {
      currentPlayer = player === HUMAN ? AI : HUMAN;
      // Update ghost visibility when turn changes
      ghostTiles.forEach((ghost, idx) => {
        renderGhostTile(idx);
      });
      updateDestroyTargetPulsation();
      startCardDraftFor(currentPlayer);
    }

    function checkForcedAmbushMove() {
      // Get all empty tiles (not blocked, not mystery, not already occupied)
      // Include tiles with ghosts that haven't formed yet (they can be claimed)
      const emptyTiles = getEmptyIndices(board, { includeMystery: false })
        .filter(idx => {
          const ghost = ghostTiles.get(idx);
          // Can move to empty tile or enemy ghost that hasn't formed
          if (ghost && ghost.owner === currentPlayer && ghost.turns < 3) {
            return false; // Can't move to own unformed ghost
          }
          return true;
        });
      
      // If there's exactly one empty tile left
      if (emptyTiles.length === 1) {
        const lastTile = emptyTiles[0];
        const ambushOwner = getAmbushOwner(lastTile);
        const ghost = ghostTiles.get(lastTile);
        
        // If there's a ghost that hasn't formed, ambush doesn't trigger until ghost forms
        if (ghost && ghost.turns < 3) {
          // Ghost hasn't formed yet, so ambush is delayed
          return null; // Not a forced move yet
        }
        
        // If there's an ambush (regardless of owner), force the move and activate it
        if (ambushOwner) {
          if (currentPlayer === HUMAN) {
            resolveAmbushSpring(HUMAN, lastTile, ambushOwner);
          } else {
            resolveAmbushSpring(AI, lastTile, ambushOwner);
          }
          return 'activated';
        }
      }
      
      return null;
    }

    function checkGameState() {
      const winnerInfo = getWinner(board);
      if (winnerInfo) {
        handleWin(winnerInfo);
        return true;
      }

      // Check for forced ambush move before checking for draw
      const forcedAmbushResult = checkForcedAmbushMove();
      if (forcedAmbushResult === 'activated') {
        // Ambush was activated, check game state again after
        return checkGameState();
      }

      // Only draw when all tiles are actually occupied (letters or hexes)
      // AND there are no unrevealed mystery tiles (they must be revealed first)
      const allOccupied = board.every(cell => cell);
      const noUnrevealedMysteryTiles = mysteryTileIndices.length === 0;
      if (allOccupied && noUnrevealedMysteryTiles) {
        handleDraw();
        return true;
      }
      return false;
    }

    function evaluateBoardStateAfterAuto() {
      if (gameOver) return true;
      return checkGameState();
    }

    function handleWin(winnerInfo) {
      gameOver = true;
      highlightWinner(winnerInfo.line);
      const winner = winnerInfo.player;
      statusElement.textContent = `Player ${winner} claims Round ${currentRound}!`;
      disableBoard();
      waitingForAI = false;
      setTimeout(() => {
        showWinCelebration(winner);
        completeRound({ winner });
      }, 1250);
    }

    function handleDraw(message) {
      gameOver = true;
      statusElement.textContent = message || `Round ${currentRound} ends in a draw.`;
      waitingForAI = false;
      disableBoard();
      completeRound();
    }

    function triggerForcedDraw(reason) {
      if (gameOver) return;
      handleDraw(reason || 'No moves remain. The round ends in a draw.');
    }

    function completeRound({ winner = null } = {}) {
      if (roundResolved) return;
      roundResolved = true;
      const finishedRound = currentRound;
      const roundPoints = tallyRoundScores(winner, finishedRound);
      const summaryDelay = winner ? 1000 : 0;
      showRoundPointTotals(roundPoints, summaryDelay);
      const overlayHoldMs = 2000;
      const nextRoundDelay = summaryDelay + overlayHoldMs;
      updateScoreDisplay();
      waitingForAI = false;

      // Determine who goes first next round
      let nextStartingPlayer = HUMAN; // Default for first round
      
      if (winner) {
        // Winner exists - loser goes first next round
        nextStartingPlayer = winner === HUMAN ? AI : HUMAN;
        
        if (finishedRound >= TOTAL_ROUNDS) {
          setTimeout(() => {
            showCampaignFinale();
          }, nextRoundDelay);
          return;
        }

        currentRound += 1;
        updateScoreDisplay();
        const playerLabel = nextStartingPlayer === HUMAN ? 'Player X' : 'AI';
        scheduleNextRound({
          statusMessage: `Round ${currentRound}: ${playerLabel} chooses Card`,
          startingPlayer: nextStartingPlayer,
          delay: nextRoundDelay
        });
      } else {
        // Draw - loser (player with fewer points) goes first
        // If points are equal, alternate (opposite of who went first this round)
        if (roundPoints.X < roundPoints.O) {
          nextStartingPlayer = HUMAN;
        } else if (roundPoints.O < roundPoints.X) {
          nextStartingPlayer = AI;
        } else {
          // Points are equal - alternate from who went first this round
          nextStartingPlayer = currentPlayer === HUMAN ? AI : HUMAN;
        }
        const playerLabel = nextStartingPlayer === HUMAN ? 'Player X' : 'AI';
        scheduleNextRound({
          statusMessage: `Draw. Round ${currentRound} rematch! ${playerLabel} chooses Card`,
          startingPlayer: nextStartingPlayer,
          delay: nextRoundDelay
        });
      }
    }

    function showCampaignFinale() {
      if (campaignOverlayTimeout) {
        clearTimeout(campaignOverlayTimeout);
        campaignOverlayTimeout = null;
      }
      hideWinCelebration();
      const playerScore = scores.X;
      const aiScore = scores.O;
      let verdict = '';
      if (playerScore === aiScore) {
        verdict = "IT'S A TIE!";
      } else if (playerScore > aiScore) {
        verdict = 'YOU WIN!!!!!! :}';
      } else {
        verdict = 'YOU LOST!!!!! :(';
      }
      if (campaignMessage) {
        campaignMessage.innerHTML = `
          <div class="final-score-line">X Points: ${playerScore}</div>
          <div class="final-score-line">O Points: ${aiScore}</div>
          <div class="final-status">${verdict}</div>
        `;
      }
      campaignOverlay?.classList?.add('show');
      campaignOverlayTimeout = setTimeout(() => {
        campaignOverlay?.classList?.remove('show');
        campaignOverlayTimeout = null;
        resetRound(true, { statusMessage: 'Round 1: Player X chooses Card', resetCampaign: true });
      }, 3000);
    }

    function tallyRoundScores(winner, roundNumber) {
      const weights = tileWeights.length === board.length
        ? tileWeights
        : computeTileWeights(boardSize);
      const roundPoints = { X: 0, O: 0 };
      board.forEach((cell, idx) => {
        if (cell === HUMAN) {
          roundPoints.X += weights[idx] || 1;
        } else if (cell === AI) {
          roundPoints.O += weights[idx] || 1;
        }
      });
      if (winner === HUMAN) roundPoints.X += roundNumber;
      if (winner === AI) roundPoints.O += roundNumber;
      scores.X += roundPoints.X;
      scores.O += roundPoints.O;
      lastRoundPoints = roundPoints;
      return roundPoints;
    }

    function updateScoreDisplay() {
      scoreElements.X.textContent = scores.X;
      scoreElements.O.textContent = scores.O;
      if (roundElement) {
        roundElement.textContent = Math.min(currentRound, TOTAL_ROUNDS);
      }
    }

    function showRoundPointTotals(roundPoints, delay = 0) {
      if (roundSummaryTimeout) {
        clearTimeout(roundSummaryTimeout);
        roundSummaryTimeout = null;
      }
      roundSummaryTimeout = setTimeout(() => {
        winMessage.classList.add('round-summary');
        winMessage.innerHTML = `
          <span class="round-points-line">X - ${roundPoints.X} points</span>
          <span class="round-points-line">O - ${roundPoints.O} points</span>
        `;
        winOverlay.classList.add('show');
        winOverlay.classList.add('summary-mode');
        roundSummaryTimeout = null;
      }, Math.max(0, delay));
    }

    function makeMove(idx, player, skipAmbushCheck = false) {
      // Clear ghost if present
      if (isGhostTile(idx)) {
        clearGhostAt(idx);
      }
      board[idx] = player;
      const tile = boardElement.children[idx];
      if (tile) {
        removeTileFadeOverlay(tile);
        clearTilePreviewState(idx);
        tile.textContent = player;
        applyTileMark(tile, player);
      }
      // Check for ambush after placing tile (unless already handling it)
      if (!skipAmbushCheck) {
        checkAndTriggerAmbush(idx, player);
      }
    }

    function checkAndTriggerAmbush(idx, player) {
      const ambushOwner = getAmbushOwner(idx);
      if (ambushOwner && ambushOwner !== player) {
        // Check if this ambush can be triggered by this player
        // AI's ambush can only be triggered by HUMAN
        // HUMAN's ambush can only be triggered by AI
        const canTrigger = (ambushOwner === AI && player === HUMAN) || 
                          (ambushOwner === HUMAN && player === AI);
        if (canTrigger) {
          // Opposing player placed on ambush - trigger it
          triggerAmbush(idx, player, ambushOwner);
          finishAmbushTurn(player);
          return true; // Ambush was triggered
        } else {
          // This player cannot trigger this ambush - just clear it
          clearAmbushAt(idx);
        }
      } else if (ambushOwner === player) {
        // Player placed on their own ambush - just clear it (deactivate)
        clearAmbushAt(idx);
      }
      return false; // No ambush triggered
    }

    function highlightWinner(line) {
      line.forEach(idx => {
        const tile = boardElement.children[idx];
        if (tile) tile.classList.add('win');
      });
    }

    function disableBoard() {
      [...boardElement.children].forEach(btn => btn.disabled = true);
      waitingForAI = false;
      clearAllHoverPreviews();
    }

    function resetRound(arg1 = {}, arg2 = {}) {
      let resetCampaign = false;
      let options = {};
      if (typeof arg1 === 'boolean') {
        resetCampaign = arg1;
        options = arg2 || {};
      } else if (typeof arg1 === 'object' && arg1 !== null) {
        options = arg1;
      }

      if (nextRoundTimeout) {
        clearTimeout(nextRoundTimeout);
        nextRoundTimeout = null;
      }
      if (aiChoiceTimeout) {
        clearTimeout(aiChoiceTimeout);
        aiChoiceTimeout = null;
      }
      if (aiCardSelectionTimeout) {
        clearTimeout(aiCardSelectionTimeout);
        aiCardSelectionTimeout = null;
      }
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }
      if (previewTimeout) {
        clearTimeout(previewTimeout);
        previewTimeout = null;
      }
      weightPreviewActive = false;
      clearAmbushEffects();
      clearChainEffects();
      cleanupToenado();
      ghostTiles.clear();
      fortressTiles.clear();

      aiCataclysmPending = false;
      if (resetCampaign || options.resetCampaign) {
        scores.X = 0;
        scores.O = 0;
        currentRound = 1;
        lastRoundPoints = { X: 0, O: 0 };
      }
      hideWinCelebration();

      const effectiveRound = Math.min(currentRound, TOTAL_ROUNDS);
      boardSize = getBoardSizeForRound(effectiveRound);
      winCondition = boardSize;
      board = Array(boardSize * boardSize).fill('');
      tileWeights = computeTileWeights(boardSize);
      winningLines = generateWinningLines(boardSize, winCondition);
      ambushTraps = new Map();
      ghostTiles.clear();
      initBoard();

      // Set starting player (default to HUMAN for first round, or use provided startingPlayer)
      const startingPlayer = (effectiveRound === 1) ? HUMAN : (options.startingPlayer || HUMAN);
      currentPlayer = startingPlayer;
      gameOver = false;
      roundResolved = false;
      waitingForAI = false;
      const playerLabel = startingPlayer === HUMAN ? 'Player X' : 'AI';
      const message = options.statusMessage || `Round ${effectiveRound}: ${playerLabel} chooses Card`;
      statusElement.textContent = message;
      [...boardElement.children].forEach(btn => {
        btn.textContent = '';
        btn.disabled = false;
        btn.classList.remove('win', 'blocked', 'mystery', 'ambush', 'ghost', 'ghost-turn-0', 'ghost-turn-1', 'ghost-turn-2', 'ghost-turn-3', 'hidden-ghost', 'selected', 'pulsate', 'fortress');
        removeTileFadeOverlay(btn);
        clearTileMark(btn);
        const ghostMark = btn.querySelector('.ghost-mark');
        if (ghostMark) {
          ghostMark.remove();
        }
      });

      updateScoreDisplay();

      playerState.X = createEmptyState();
      playerState.O = createEmptyState();
      // Create empty card boxes immediately for both players
      const humanGrid = cardPanels.X?.grid;
      if (humanGrid) {
        humanGrid.innerHTML = '';
        for (let i = 0; i < 3; i++) {
          const blankCard = document.createElement('div');
          blankCard.className = 'card disabled';
          blankCard.innerHTML = '';
          humanGrid.appendChild(blankCard);
        }
      }
      const aiGrid = cardPanels.O?.grid;
      if (aiGrid) {
        aiGrid.innerHTML = '';
        for (let i = 0; i < 3; i++) {
          const blankCard = document.createElement('div');
          blankCard.className = 'card disabled';
          blankCard.innerHTML = '';
          aiGrid.appendChild(blankCard);
        }
      }
      showTileWeightPreview();
      // Delay card text rendering until tile preview is fully gone (1.75 seconds)
      setTimeout(() => {
        startCardDraftFor(startingPlayer);
      }, 1750);
    }

    function scheduleNextRound(options = {}) {
      const { delay = 2000, statusMessage, startingPlayer = HUMAN } = options;
      if (nextRoundTimeout) clearTimeout(nextRoundTimeout);
      nextRoundTimeout = setTimeout(() => {
        resetRound({ statusMessage, startingPlayer });
        nextRoundTimeout = null;
      }, delay);
    }

    function scheduleAIMove() {
      // Clear any existing timeout
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }
      
      // Ensure waitingForAI is set when AI is supposed to move
      if (currentPlayer === AI) {
        waitingForAI = true;
      }
      
      statusElement.textContent = 'AI is thinking...';
      const aiMoveDelay = Math.round(randomDelay(1250, 1750));
      
      // Set up the actual move
      setTimeout(() => {
        if (!gameOver && currentPlayer === AI) {
          aiMove();
        }
      }, aiMoveDelay);
      
      // Safety timeout: if AI hasn't made a move after 3 seconds, force end turn
      aiMoveTimeout = setTimeout(() => {
        // Check if AI is still the current player - if so, it's stuck
        if (!gameOver && currentPlayer === AI) {
          const aiState = playerState[AI];
          // AI is stuck, force it to end its turn
          waitingForAI = false;
          if (aiState) {
            if (aiState.awaitingChoice) {
              aiState.awaitingChoice = false;
            }
            if (aiState.ready) {
              aiState.ready = false;
            }
          }
          // Force end the turn
          processTurnResult(AI);
        }
        aiMoveTimeout = null;
      }, 3000);
    }

    function aiMove() {
      // Clear the safety timeout since we're making a move
      if (aiMoveTimeout) {
        clearTimeout(aiMoveTimeout);
        aiMoveTimeout = null;
      }
      
      if (gameOver) {
        waitingForAI = false;
        return;
      }
      const blockIdx = findCriticalBlockMove();
      if (blockIdx !== -1) {
        makeMove(blockIdx, AI);
        processTurnResult(AI);
        return;
      }
      const destroyPending = maybeAIDestroyTile();
      if (destroyPending) {
        // Destroy will happen after 1.5 seconds, don't make a regular move
        return;
      }
      if (!gameOver && currentPlayer === AI && playerState[AI].ready && attemptAIMysteryTile()) {
        processTurnResult(AI);
        return;
      }
      
      // Check for forced ambush move before finding best move
      const forcedAmbushResult = checkForcedAmbushMove();
      if (forcedAmbushResult === 'activated') {
        // Ambush was activated, resolveAmbushSpring already handled turn switching
        // Just check game state to see if game ended
        waitingForAI = false;
        checkGameState();
        return;
      }
      
      const move = findBestMove(board);
      if (move === -1) {
        // Check if there are unrevealed mystery tiles - they must be revealed before a draw
        const availableMystery = mysteryTileIndices.filter(idx => !board[idx] && isMysteryTile(idx));
        if (availableMystery.length > 0) {
          // There are mystery tiles available - resolve one (mystery tiles must be revealed before draw)
          const mysteryIdx = availableMystery[Math.floor(Math.random() * availableMystery.length)];
          const trapOwner = getAmbushOwner(mysteryIdx);
          if (trapOwner && trapOwner !== AI) {
            resolveAmbushSpring(AI, mysteryIdx, trapOwner);
            return;
          }
          if (trapOwner === AI) {
            clearAmbushAt(mysteryIdx);
          }
          resolveMysteryTile(AI, mysteryIdx);
          processTurnResult(AI);
          return;
        }
        waitingForAI = false;
        triggerForcedDraw('AI cannot move. Round declared a draw.');
        return;
      }
      
      // Check for enemy ghost that hasn't formed yet - can claim it to kill the ghost
      const enemyGhost = ghostTiles.get(move);
      if (enemyGhost && enemyGhost.owner !== AI && enemyGhost.turns < 3) {
        clearGhostAt(move);
        statusElement.textContent = 'AI claimed the tile and destroyed your ghost!';
        makeMove(move, AI);
        processTurnResult(AI);
        return;
      }
      
      const trapOwner = getAmbushOwner(move);
      if (trapOwner && trapOwner !== AI) {
        // Opponent's ambush - trigger it
        resolveAmbushSpring(AI, move, trapOwner);
        return;
      }
      // If placing on own ambush, makeMove will clear it (via checkAndTriggerAmbush)
      // Clear own ghost if present
      if (isGhostTile(move)) {
        clearGhostAt(move);
      }
      makeMove(move, AI); // checkAndTriggerAmbush will handle own ambush clearing
      processTurnResult(AI);
    }

    function findBestMove(state) {
      if (boardSize === BASE_BOARD_SIZE && winCondition === BASE_BOARD_SIZE) {
        let bestScore = -Infinity;
        let move = -1;
        state.forEach((cell, idx) => {
          if (!cell && !isMysteryTile(idx) && !isGhostTile(idx)) {
            state[idx] = AI;
            const score = minimax(state, false, 0);
            state[idx] = '';
            if (score > bestScore) {
              bestScore = score;
              move = idx;
            }
          }
        });
        return move;
      }
      return findLargeBoardMove(state);
    }

    function findLargeBoardMove(state) {
      const empties = getEmptyIndices(state);
      if (!empties.length) return -1;

      for (const idx of empties) {
        state[idx] = AI;
        if (isPlayerWinning(state, AI)) {
          state[idx] = '';
          return idx;
        }
        state[idx] = '';
      }

      for (const idx of empties) {
        state[idx] = HUMAN;
        if (isPlayerWinning(state, HUMAN)) {
          state[idx] = '';
          return idx;
        }
        state[idx] = '';
      }

      const preferred = getPreferredIndices();
      for (const idx of preferred) {
        if (empties.includes(idx)) return idx;
      }

      return empties[Math.floor(Math.random() * empties.length)];
    }

    function findCriticalBlockMove() {
      for (const line of winningLines) {
        let humanCount = 0;
        let invalidLine = false;
        const empties = [];
        for (const idx of line) {
          const cell = board[idx];
          if (cell === HUMAN) {
            humanCount++;
          } else if (cell === AI || cell === 'BLOCK' || isMysteryTile(idx) || isGhostTile(idx)) {
            invalidLine = true;
            break;
          } else {
            empties.push(idx);
          }
        }
        if (!invalidLine && humanCount === winCondition - 1 && empties.length === 1) {
          return empties[0];
        }
      }
      return -1;
    }

    function minimax(state, isMaximizing, depth) {
      const winnerInfo = getWinner(state);
      if (winnerInfo && winnerInfo.player === AI) return 10 - depth;
      if (winnerInfo && winnerInfo.player === HUMAN) return depth - 10;
      if (state.every(cell => cell)) return 0;

      if (isMaximizing) {
        let bestScore = -Infinity;
        state.forEach((cell, idx) => {
          if (!cell && !isMysteryTile(idx) && !isGhostTile(idx)) {
            state[idx] = AI;
            bestScore = Math.max(bestScore, minimax(state, false, depth + 1));
            state[idx] = '';
          }
        });
        return bestScore;
      } else {
        let bestScore = Infinity;
        state.forEach((cell, idx) => {
          if (!cell && !isMysteryTile(idx) && !isGhostTile(idx)) {
            state[idx] = HUMAN;
            bestScore = Math.min(bestScore, minimax(state, true, depth + 1));
            state[idx] = '';
          }
        });
        return bestScore;
      }
    }

    function getWinner(state) {
      for (const line of winningLines) {
        // Find the first real tile (not an unformed ghost) in the line
        let first = null;
        for (const idx of line) {
          const ghost = ghostTiles.get(idx);
          // CRITICAL: Unformed ghosts (turns < 3) don't count - treat as empty
          if (ghost && ghost.turns < 3) continue;
          const cell = state[idx];
          // Only count real tiles in the board array
          if (cell === HUMAN || cell === AI) {
            first = cell;
            break;
          }
        }
        
        // If no real tile found in the line, skip it
        if (!first) continue;
        
        // Check if all cells in the line match (ignoring unformed ghosts)
        const allMatch = line.every(idx => {
          const ghost = ghostTiles.get(idx);
          // CRITICAL: Unformed ghosts (turns < 3) don't count - treat as empty
          // Even if board[idx] is somehow set incorrectly, unformed ghosts should never count
          if (ghost && ghost.turns < 3) {
            // This position is empty (ghost hasn't formed), so it can't match
            return false;
          }
          const cell = state[idx];
          // Must match the first tile we found AND be a real tile (not empty)
          return cell === first && cell !== '';
        });
        
        if (allMatch) {
          return { player: first, line };
        }
      }
      return null;
    }

    function isPlayerWinning(state, player) {
      return winningLines.some(line => {
        // Check if all cells in the line belong to the player (ignoring unformed ghosts)
        // CRITICAL: Unformed ghosts (turns < 3) don't count - they're treated as empty
        return line.every(idx => {
          const ghost = ghostTiles.get(idx);
          // If there's an unformed ghost, this position is empty and can't be part of a win
          if (ghost && ghost.turns < 3) {
            return false; // This position doesn't count toward the win
          }
          // Only count real tiles in the board array
          const cell = state[idx];
          return cell === player;
        });
      });
    }

    function startCardDraftFor(player) {
      clearAllHoverPreviews();
      const state = playerState[player];
      state.awaitingChoice = true;
      state.ready = false;
      state.card = null;
      state.extraTurnAvailable = false;
      state.extraTurnUsed = false;
      state.destroyAvailable = false;
      state.destroyUsed = false;
      state.destroyMode = 'single';
      state.choices = [];
      state.ambushAvailable = false;
      state.ambushArming = false;
      state.hexArming = false;
      // If OMFG was armed, disable hex tiles again
      if (state.omfgArming) {
        disableHexTilesAfterOMFG();
      }
      state.omfgArming = false;
      state.toenadoArming = false;
      if (player === HUMAN) {
        renderCardChoices(player);
        waitingForAI = false;
        statusElement.textContent = 'Player X chooses Card';
        cardPanels.X?.panel?.classList?.add('selectable');
      } else {
        // Fade out text in human player's cards when AI's turn starts (left to right, 1 second total)
        const humanGrid = cardPanels[HUMAN]?.grid;
        if (humanGrid) {
          [...humanGrid.children].forEach((cardEl, idx) => {
            if (cardEl && cardEl.querySelector('.card-title')) {
              cardEl.classList.remove('fade-in', 'selected', 'glow-active');
              // Apply staggered fade-out delays: 0ms, 325ms, 650ms (total ~1 second)
              const titleEl = cardEl.querySelector('.card-title');
              const textEl = cardEl.querySelector('.card-text');
              if (titleEl) titleEl.style.animationDelay = `${idx * 325}ms`;
              if (textEl) textEl.style.animationDelay = `${idx * 325}ms`;
              cardEl.classList.add('fade-out');
              // Clear text after all animations complete (1 second)
              setTimeout(() => {
                cardEl.innerHTML = '';
                cardEl.classList.remove('fade-out');
                if (titleEl) titleEl.style.animationDelay = '';
                if (textEl) textEl.style.animationDelay = '';
              }, 1000);
            }
          });
        }
        // Generate choices for AI and render them for debugging
        renderCardChoices(player);
        waitingForAI = true;
        statusElement.textContent = 'AI chooses Card';
        cardPanels.X?.panel?.classList?.remove('selectable');
        if (aiChoiceTimeout) clearTimeout(aiChoiceTimeout);
        if (aiCardSelectionTimeout) clearTimeout(aiCardSelectionTimeout);
        const aiDrawDelay = Math.round(randomDelay(500, 1000));
        aiChoiceTimeout = setTimeout(() => {
          applyAISelection();
          aiChoiceTimeout = null;
        }, aiDrawDelay);
        // Safety timeout: if AI hasn't selected a card after 3 seconds, skip to manual placement
        aiCardSelectionTimeout = setTimeout(() => {
          const aiState = playerState[AI];
          if (aiState && aiState.awaitingChoice && !aiState.ready && currentPlayer === AI && !gameOver) {
            // AI is stuck, force it to skip card selection
            aiState.awaitingChoice = false;
            aiState.ready = true;
            scheduleAIMove();
          }
          aiCardSelectionTimeout = null;
        }, 3000);
      }
    }

    function drawCard() {
      const available = cardPool.filter(card => isCardAvailable(card));
      const pool = available.length ? available : cardPool;
      const index = Math.floor(Math.random() * pool.length);
      return pool[index];
    }

    function isCardAvailable(card) {
      if (!card) return false;
      if (card.effect === 'emmaBloom' && currentRound < 4) {
        return false;
      }
      // Ghosts card is disabled from selection (code kept for future use)
      if (card.effect === 'ghosts') {
        return false;
      }
      return true;
    }

    function generateCardChoices(player) {
      const choices = [drawCard(), drawCard(), drawCard()];
      playerState[player].choices = choices;
      return choices;
    }

    function renderCardChoices(player) {
      const choices = generateCardChoices(player);
      const grid = cardPanels[player]?.grid;
      if (!grid) return;
      
      // Ensure we have 3 card elements (create blank ones if needed)
      while (grid.children.length < 3) {
        const blankCard = document.createElement('div');
        blankCard.className = 'card disabled';
        blankCard.innerHTML = '';
        grid.appendChild(blankCard);
      }
      
      // Update existing cards in place - never remove or replace the DOM elements
      choices.forEach((card, idx) => {
        const cardEl = grid.children[idx];
        if (!cardEl) return;
        
        // Update content directly - this keeps the element in place visually
        cardEl.className = 'card fade-in';
        cardEl.classList.remove('glow-active');
        cardEl.innerHTML = `
          <div class="card-title" style="animation-delay: ${idx * 244}ms">${card.name}</div>
          <p class="card-text" style="animation-delay: ${idx * 244}ms">${card.description}</p>
        `;
        
        // Use event delegation on the grid instead of individual listeners
        // This avoids needing to remove old listeners
        if (player === HUMAN) {
          cardEl.classList.remove('disabled');
          // Remove any existing data attribute and set new one for delegation
          cardEl.removeAttribute('data-card-index');
          cardEl.setAttribute('data-card-index', idx);
          
          // Add glow when text finishes fading in (0.26s animation + delay)
          const glowDelay = (idx * 244) + 260;
          setTimeout(() => {
            cardEl.classList.add('glow-active');
          }, glowDelay);
        } else {
          cardEl.classList.add('disabled');
        }
      });
      
      // Set up event delegation on the grid if human player
      if (player === HUMAN) {
        // Remove old delegation listener if any
        grid.removeEventListener('click', grid._cardClickHandler);
        // Create new delegation handler
        grid._cardClickHandler = (e) => {
          const cardEl = e.target.closest('.card');
          if (cardEl && !cardEl.classList.contains('disabled')) {
            const idx = parseInt(cardEl.getAttribute('data-card-index'));
            if (!isNaN(idx)) {
              handleCardSelection(player, idx);
            }
          }
        };
        grid.addEventListener('click', grid._cardClickHandler);
      }
    }

    function handleCardSelection(player, choiceIndex) {
      const state = playerState[player];
      if (!state || !state.awaitingChoice) return;
      const choices = state.choices || [];
      const card = choices[choiceIndex];
      if (!card) return;

      state.card = card;
      state.awaitingChoice = false;
      state.choices = [];
      const grid = cardPanels[player]?.grid;
      if (grid) {
        [...grid.children].forEach((child, idx) => {
          if (idx === choiceIndex) {
            child.classList.add('selected');
            child.classList.remove('disabled');
          } else {
            child.classList.remove('selected');
            child.classList.add('disabled');
          }
        });
      }
      cardPanels[player]?.panel?.classList?.remove('selectable');

      state.extraTurnAvailable = card.effect === 'extraTurn';
      state.extraTurnUsed = false;
      if (card.effect === 'destroyTile' || card.effect === 'destroyConnected') {
        state.destroyAvailable = true;
        state.destroyMode = card.effect === 'destroyConnected' ? 'chain' : 'single';
      } else {
        state.destroyAvailable = false;
        state.destroyMode = 'single';
      }
      state.destroyUsed = false;
      updateDestroyTargetPulsation();
      state.switcharooActive = false;
      state.hexArming = false;
      state.fortressArming = false;
      // If OMFG was armed, disable hex tiles again
      if (state.omfgArming) {
        disableHexTilesAfterOMFG();
      }
      state.omfgArming = false;
      state.toenadoArming = false;

      const turnConsumedByCard = false;
      const effectOutcome = applyCardEffect(player, card);
      const pendingEffect = effectOutcome === CARD_FLOW.PENDING;
      const effectConsumedTurn = effectOutcome === CARD_FLOW.CONSUME;
      const omfgAnimating = effectOutcome === 'OMFG_ANIMATING';

      if (gameOver) {
        return;
      }

      if (card.effect === 'ambushTrap') {
        if (player === HUMAN) {
          state.ready = false;
        } else {
          if (!gameOver) {
            state.ready = true;
            scheduleAIMove();
          }
        }
        return;
      }

      if (card.effect === 'fortress') {
        if (player === HUMAN) {
          state.ready = false;
        }
        return;
      }

      if (pendingEffect) {
        state.ready = false;
        return;
      }

      if (player === HUMAN) {
        if (turnConsumedByCard || effectConsumedTurn || omfgAnimating) {
          state.ready = false;
          statusElement.textContent = getConsumeMessage(player, card);
          if (!gameOver) {
            // For OMFG, wait for animation to complete (1 second)
            const delay = omfgAnimating ? 1000 : 0;
            setTimeout(() => {
              if (!gameOver) {
                processTurnResult(HUMAN);
              }
            }, delay);
          }
          return;
        }
        state.ready = true;
        statusElement.textContent = 'Card ready. Place your mark.';
      } else {
        if (aiChoiceTimeout) {
          clearTimeout(aiChoiceTimeout);
          aiChoiceTimeout = null;
        }
        if (aiCardSelectionTimeout) {
          clearTimeout(aiCardSelectionTimeout);
          aiCardSelectionTimeout = null;
        }
        if (turnConsumedByCard || effectConsumedTurn || omfgAnimating) {
          state.ready = false;
          statusElement.textContent = getConsumeMessage(player, card);
          if (!gameOver) {
            // For OMFG, wait for animation to complete (1 second)
            const delay = omfgAnimating ? 1000 : 0;
            setTimeout(() => {
              if (!gameOver) {
                processTurnResult(AI);
              }
            }, delay);
          }
          return;
        }
        state.ready = true;
        scheduleAIMove();
      }
    }

    function applyAISelection() {
      const state = playerState[AI];
      if (!state || state.awaitingChoice === false) {
        // Can't select a card, skip to manual placement
        if (aiCardSelectionTimeout) {
          clearTimeout(aiCardSelectionTimeout);
          aiCardSelectionTimeout = null;
        }
        state.ready = true;
        scheduleAIMove();
        return;
      }
      const choices = state.choices || [];
      if (!choices.length) {
        // No cards available, skip to manual placement
        if (aiCardSelectionTimeout) {
          clearTimeout(aiCardSelectionTimeout);
          aiCardSelectionTimeout = null;
        }
        state.awaitingChoice = false;
        state.ready = true;
        scheduleAIMove();
        return;
      }
      const selectedIndex = chooseBestAICardIndex(choices);
      handleCardSelection(AI, selectedIndex);
    }

    function chooseBestAICardIndex(choices) {
      if (!choices.length) return 0;
      aiCataclysmPending = false;
      const ambushIdx = choices.findIndex(card => card.effect === 'ambushTrap');
      if (ambushIdx !== -1) {
        return ambushIdx;
      }
      const catIdx = choices.findIndex(card => card.effect === 'destroyConnected');
      if (catIdx !== -1) {
        const bestCluster = getBestCataclysmTarget();
        // Only select Cataclysm if there are X (HUMAN) tiles to target
        // bestCluster.index !== -1 means there's at least one HUMAN tile available
        if (bestCluster.index !== -1 && bestCluster.size >= 2 && board[bestCluster.index] === HUMAN) {
          aiCataclysmPending = true;
          return catIdx;
        }
        // If no HUMAN tiles available, skip Cataclysm entirely
      }
      const roll = Math.random();
      const preferredOrder = ['extraTurn', 'destroyConnected', 'emmaBloom', 'fortress', 'ghosts', 'destroyTile', 'cleanseTile', 'claimCenter', 'claimCorner', 'claimEdge', 'claimRandom', 'doubleVoid', 'voidTile'];
      const scored = choices.map((card, idx) => {
        // Skip Cataclysm if no HUMAN tiles are available (treat as lowest priority)
        if (card.effect === 'destroyConnected') {
          const bestCluster = getBestCataclysmTarget();
          if (bestCluster.index === -1 || board[bestCluster.index] !== HUMAN) {
            // No valid X tile targets, give it lowest priority so it's never selected
            return { idx, score: 999 };
          }
        }
        const priority = preferredOrder.indexOf(card.effect);
        const score = priority === -1 ? preferredOrder.length + idx : priority;
        return { idx, score };
      }).sort((a, b) => a.score - b.score);
      if (roll < 0.65) {
        return scored[0].idx;
      }
      return Math.floor(Math.random() * choices.length);
    }

    function applyCardEffect(player, card) {
      if (!card) return CARD_FLOW.CONTINUE;
      switch (card.effect) {
        case 'claimCenter':
          claimCenter(player);
          return CARD_FLOW.CONTINUE;
        case 'claimCorner':
          claimCorner(player);
          return CARD_FLOW.CONTINUE;
        case 'claimEdge':
          claimEdge(player);
          return CARD_FLOW.CONTINUE;
        case 'claimRandom':
          autoClaim(player, getAllIndices());
          return CARD_FLOW.CONTINUE;
        case 'voidTile':
          return triggerHex(player);
        case 'doubleVoid':
          corruptTile();
          corruptTile();
          return CARD_FLOW.CONTINUE;
        case 'cleanseTile':
          cleanseCursedTile();
          return CARD_FLOW.CONTINUE;
        case 'emmaBloom':
          return triggerEmmaBloom(player);
        case 'switcharoo':
          return triggerSwitcharoo(player);
        case 'ambushTrap':
          prepareAmbushTrap(player);
          return CARD_FLOW.PENDING;
        case 'ghosts':
          return triggerGhosts(player);
        case 'fortress':
          return triggerFortress(player);
        case 'omfg':
          return triggerOMFG(player);
        case 'toenado':
          return triggerToenado(player);
        default:
          return CARD_FLOW.CONTINUE;
      }
    }

    function claimCenter(player) {
      const centers = getCenterIndices();
      const spot = centers.find(idx => !board[idx] && !isMysteryTile(idx) && !isAmbushMarked(idx));
      if (spot !== undefined) {
        makeMove(spot, player);
        evaluateBoardStateAfterAuto();
      } else {
        autoClaim(player, getAllIndices());
      }
    }

    function claimCorner(player) {
      const corners = getCornerIndices();
      const claimed = autoClaim(player, corners);
      if (claimed === null) {
        autoClaim(player, getAllIndices());
      }
    }

    function claimEdge(player) {
      const edges = getEdgeIndices();
      const claimed = autoClaim(player, edges);
      if (claimed === null) {
        autoClaim(player, getAllIndices());
      }
    }

    function autoClaim(player, indices) {
      const pool = indices.filter(idx => !board[idx] && !isMysteryTile(idx) && !isAmbushMarked(idx));
      if (!pool.length) return null;
      const idx = pool[Math.floor(Math.random() * pool.length)];
      // Clear ghost if present
      if (isGhostTile(idx)) {
        clearGhostAt(idx);
      }
      makeMove(idx, player);
      evaluateBoardStateAfterAuto();
      return idx;
    }

    function triggerEmmaBloom(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      const opponent = player === HUMAN ? AI : HUMAN;
      const opponentTiles = getOwnedTileIndices(opponent);
      if (!opponentTiles.length) {
        statusElement.textContent = `${playerLabel(player)} has no opponent tiles to target.`;
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.emmaBloomArming = true;
        state.ready = false;
        statusElement.textContent = 'Select an opponent tile to unleash Emma Bloom.';
        return CARD_FLOW.PENDING;
      }
      const choice = chooseEmmaBloomTile(player, opponentTiles);
      if (choice === -1) {
        statusElement.textContent = 'Emma Bloom fizzles with no valid target.';
        return CARD_FLOW.CONTINUE;
      }
      executeEmmaBloom(player, choice);
      return CARD_FLOW.CONTINUE;
    }

    function attemptEmmaBloomSelection(player, idx) {
      const state = playerState[player];
      if (!state?.emmaBloomArming) return;
      const opponent = player === HUMAN ? AI : HUMAN;
      if (board[idx] !== opponent) {
        statusElement.textContent = 'Select an opponent tile for Emma Bloom.';
        return;
      }
      state.emmaBloomArming = false;
      executeEmmaBloom(player, idx);
      if (!gameOver) {
        state.ready = true;
        statusElement.textContent = `${playerLabel(player)}'s Emma Bloom overtakes nearby tiles! Place your mark.`;
      }
    }

    function executeEmmaBloom(player, originIdx) {
      // Don't convert the origin tile - it stays as opponent's tile
      // Only convert the 8 surrounding neighbor tiles
      const neighbors = getEmmaBloomNeighbors(originIdx);
      for (const neighbor of neighbors) {
        const neighborAmbushTriggered = convertTileToPlayer(neighbor, player);
        if (neighborAmbushTriggered) {
          // Ambush was triggered on a neighbor, stop processing
          return;
        }
      }
      statusElement.textContent = `${playerLabel(player)}'s Emma Bloom overtakes nearby tiles!`;
      evaluateBoardStateAfterAuto();
    }

    function convertTileToPlayer(idx, player) {
      // Cannot convert fortress tiles
      if (isFortressTile(idx)) {
        return false;
      }
      board[idx] = player;
      if (mysteryTileIndices.includes(idx)) {
        mysteryTileIndices = mysteryTileIndices.filter(i => i !== idx);
      }
      clearGhostAt(idx);
      const btn = boardElement.children[idx];
      if (btn) {
        removeTileFadeOverlay(btn);
        clearTilePreviewState(idx);
        btn.textContent = player;
        btn.disabled = false;
        btn.classList.remove('win', 'blocked', 'mystery');
        applyTileMark(btn, player);
      }
      // Check for ambush after placing tile (don't clear ambush before checking)
      const ambushTriggered = checkAndTriggerAmbush(idx, player);
      if (ambushTriggered) {
        // Ambush was triggered, don't continue with normal flow
        return true;
      }
      return false;
    }

    function getOwnedTileIndices(player) {
      return board
        .map((cell, idx) => (cell === player ? idx : null))
        .filter(idx => idx !== null);
    }

    function chooseEmmaBloomTile(player, opponentTiles = null) {
      const opponent = player === HUMAN ? AI : HUMAN;
      const tiles = opponentTiles || getOwnedTileIndices(opponent);
      if (!tiles.length) return -1;
      let bestIdx = tiles[0];
      let bestScore = -1;
      tiles.forEach(idx => {
        const neighbors = getEmmaBloomNeighbors(idx);
        const score = neighbors.reduce((total, neighbor) => {
          // Prefer tiles with more neighbors that can be converted (not already player's, not blocked)
          if (board[neighbor] === player) return total;
          if (board[neighbor] === 'BLOCK' || isMysteryTile(neighbor) || isGhostTile(neighbor)) return total;
          return total + 1;
        }, 0);
        if (score > bestScore) {
          bestScore = score;
          bestIdx = idx;
        }
      });
      return bestIdx;
    }

    function triggerSwitcharoo(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      const candidates = getSwitcharooCandidates();
      if (!candidates.length) {
        statusElement.textContent = 'Switcharoo finds no letters to flip.';
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.switcharooActive = true;
        state.ready = false;
        statusElement.textContent = 'Select any letter to flip with Switcharoo.';
        return CARD_FLOW.PENDING;
      }
      const target = chooseSwitcharooTarget(player, candidates);
      if (target === -1) {
        statusElement.textContent = 'Switcharoo fizzles with no valid tile.';
        return CARD_FLOW.CONTINUE;
      }
      flipTileSymbol(target);
      statusElement.textContent = 'AI flips a letter with Switcharoo!';
      evaluateBoardStateAfterAuto();
      return CARD_FLOW.CONTINUE;
    }

    function attemptSwitcharooSelection(player, idx) {
      const state = playerState[player];
      if (!state?.switcharooActive) return false;
      if (!isValidSwitcharooTarget(idx)) {
        statusElement.textContent = 'Switcharoo fizzles on that tile.';
        return true;
      }
      state.switcharooActive = false;
      state.ready = true;
      flipTileSymbol(idx);
      statusElement.textContent = `${playerLabel(player)} flips a letter with Switcharoo! Place your mark.`;
      evaluateBoardStateAfterAuto();
      return true;
    }

    function triggerHex(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      const availableTiles = getEmptyIndices(board, { includeMystery: false });
      if (!availableTiles.length) {
        statusElement.textContent = 'No empty tiles available to hex.';
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.hexArming = true;
        state.ready = false;
        statusElement.textContent = 'Select an empty tile to hex. (Can dismantle ambush traps!)';
        return CARD_FLOW.PENDING;
      }
      const target = chooseHexTileFor(player, availableTiles);
      if (target === -1) {
        statusElement.textContent = 'Hex fizzles with no valid target.';
        return CARD_FLOW.CONTINUE;
      }
      const hadAmbush = isAmbushMarked(target);
      const ambushOwner = hadAmbush ? getAmbushOwner(target) : null;
      hexTile(target);
      if (hadAmbush && ambushOwner !== player) {
        statusElement.textContent = 'AI hexes a tile and dismantles your ambush trap!';
      } else {
        statusElement.textContent = 'AI hexes a tile!';
      }
      evaluateBoardStateAfterAuto();
      return CARD_FLOW.CONTINUE;
    }

    function attemptHexPlacement(player, idx) {
      const state = playerState[player];
      if (!state?.hexArming) return;
      if (board[idx] || board[idx] === 'BLOCK' || isMysteryTile(idx)) {
        statusElement.textContent = 'Choose an empty tile to hex.';
        return;
      }
      state.hexArming = false;
      const hadAmbush = isAmbushMarked(idx);
      const ambushOwner = hadAmbush ? getAmbushOwner(idx) : null;
      hexTile(idx);
      evaluateBoardStateAfterAuto();
      if (!gameOver) {
        state.ready = true;
        if (hadAmbush && ambushOwner !== player) {
          statusElement.textContent = `${playerLabel(player)} hexes a tile and dismantles ${playerLabel(ambushOwner)}'s ambush trap! Place your mark.`;
        } else {
          statusElement.textContent = `${playerLabel(player)} hexes a tile! Place your mark.`;
        }
      }
    }

    function hexTile(idx) {
      if (idx < 0 || idx >= board.length) return;
      if (board[idx] || board[idx] === 'BLOCK' || isMysteryTile(idx)) return;
      clearAmbushAt(idx);
      clearGhostAt(idx);
      board[idx] = 'BLOCK';
      clearTilePreviewState(idx);
      const btn = boardElement.children[idx];
      if (btn) {
        removeTileFadeOverlay(btn);
        btn.textContent = '#';
        btn.disabled = true;
        btn.classList.add('blocked');
        clearTileMark(btn);
      }
    }

    function chooseHexTileFor(player, availableTiles) {
      if (!availableTiles.length) return -1;
      const opponent = player === HUMAN ? AI : HUMAN;
      // AI doesn't know where opponent's ambush traps are - treat all tiles equally
      const strategicTiles = availableTiles.filter(idx => {
        const neighbors = getNeighborIndices(idx);
        return neighbors.some(neighbor => board[neighbor] === opponent);
      });
      const pool = strategicTiles.length ? strategicTiles : availableTiles;
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function isValidSwitcharooTarget(idx) {
      if (idx < 0 || idx >= board.length) return false;
      if (isAmbushMarked(idx)) return false;
      const cell = board[idx];
      if (cell !== HUMAN && cell !== AI) return false;
      return true;
    }

    function getSwitcharooCandidates() {
      return board
        .map((cell, idx) => {
          if (cell !== HUMAN && cell !== AI) return null;
          if (isAmbushMarked(idx) || cell === 'BLOCK') return null;
          return idx;
        })
        .filter(idx => idx !== null);
    }

    function chooseSwitcharooTarget(player, candidates) {
      if (!candidates?.length) return -1;
      const opponent = player === HUMAN ? AI : HUMAN;
      const opponentTiles = candidates.filter(idx => board[idx] === opponent);
      if (opponentTiles.length) {
        return opponentTiles[Math.floor(Math.random() * opponentTiles.length)];
      }
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    function flipTileSymbol(idx) {
      // Cannot flip fortress tiles
      if (isFortressTile(idx)) {
        return false;
      }
      const current = board[idx];
      if (current !== HUMAN && current !== AI) return false;
      const next = current === HUMAN ? AI : HUMAN;
      board[idx] = next;
      const tile = boardElement.children[idx];
      if (tile) {
        removeTileFadeOverlay(tile);
        tile.textContent = next;
        tile.classList.remove('win', 'blocked', 'mystery');
        applyTileMark(tile, next);
      }
      return true;
    }

    function corruptTile() {
      const idx = getRandomEmptyIndex({ allowMystery: false });
      if (idx === -1) {
        const hasAvailableMystery = mysteryTileIndices.some(i => !board[i]);
        if (hasAvailableMystery) {
          statusElement.textContent = 'No safe tiles to corrupt. The curse fizzles.';
          return;
        }
        triggerForcedDraw('No moves remain due to curses. Round ends in a draw.');
        return;
      }
      clearAmbushAt(idx);
      board[idx] = 'BLOCK';
      clearTilePreviewState(idx);
      const btn = boardElement.children[idx];
      if (btn) {
        removeTileFadeOverlay(btn);
        btn.textContent = '#';
        btn.disabled = true;
        btn.classList.add('blocked');
        clearTileMark(btn);
      }
    }

    function cleanseCursedTile() {
      const cursedIndices = board
        .map((cell, idx) => (cell === 'BLOCK' ? idx : null))
        .filter(idx => idx !== null);
      if (!cursedIndices.length) return;
      const idx = cursedIndices[Math.floor(Math.random() * cursedIndices.length)];
      board[idx] = '';
      const btn = boardElement.children[idx];
      if (btn) {
        removeTileFadeOverlay(btn);
        btn.textContent = '';
        btn.disabled = false;
        btn.classList.remove('blocked');
        clearTileMark(btn);
      }
    }

    function getRandomEmptyIndex(options = {}) {
      const empties = getEmptyIndices(board, { includeMystery: options.allowMystery });
      if (!empties.length) return -1;
      return empties[Math.floor(Math.random() * empties.length)];
    }

    function canUseDestroy(player) {
      const state = playerState[player];
      return Boolean(state && state.destroyAvailable && !state.destroyUsed);
    }

    function updateDestroyTargetPulsation() {
      const humanState = playerState[HUMAN];
      // Only pulsate for Erasure card (shatter-rune), not other destroy cards
      // Only pulsate O tiles when human has Erasure (not for AI)
      const humanHasErasure = humanState && humanState.card && humanState.card.id === 'shatter-rune';
      const humanShouldPulsate = humanHasErasure && humanState.destroyAvailable && !humanState.destroyUsed && currentPlayer === HUMAN && !gameOver;
      
      [...boardElement.children].forEach((tile, idx) => {
        const cell = board[idx];
        tile.classList.remove('pulsate');
        
        if (cell === AI && humanShouldPulsate) {
          // Human has Erasure - pulsate O tiles only, but exclude fortress tiles (they can't be destroyed)
          if (!isFortressTile(idx)) {
            tile.classList.add('pulsate');
          }
        }
      });
    }

    function useDestroyAbility(player, idx, statusOverride) {
      if (!canUseDestroy(player)) return false;
      const opponent = player === HUMAN ? AI : HUMAN;
      if (board[idx] !== opponent) return false;
      const state = playerState[player];
      state.destroyUsed = true;
      updateDestroyTargetPulsation();
      const targetSymbol = board[idx];
      // Check if target is a fortress tile - cannot be destroyed
      if (isFortressTile(idx)) {
        statusElement.textContent = 'That tile is protected by a Fortress and cannot be destroyed!';
        state.destroyUsed = false; // Refund the destroy ability
        updateDestroyTargetPulsation();
        return false;
      }
      
      const targets = state.destroyMode === 'chain'
        ? getConnectedCluster(idx, targetSymbol)
        : [idx];
      
      // Filter out fortress tiles from chain reactions
      const validTargets = targets.filter(targetIdx => !isFortressTile(targetIdx));
      
      if (validTargets.length === 0) {
        statusElement.textContent = 'All target tiles are protected by Fortresses!';
        state.destroyUsed = false; // Refund the destroy ability
        updateDestroyTargetPulsation();
        return false;
      }
      
      const isChainReaction = state.destroyMode === 'chain';
      
      if (isChainReaction) {
        animateCascadingCataclysm(idx, validTargets, targetSymbol);
        showChainReactionEffects();
      } else {
        validTargets.forEach(targetIdx => {
          board[targetIdx] = '';
          const btn = boardElement.children[targetIdx];
          if (btn) {
            removeTileFadeOverlay(btn);
            btn.textContent = '';
            btn.disabled = false;
            btn.classList.remove('win', 'blocked');
            clearTileMark(btn);
          }
          clearAmbushAt(targetIdx);
        });
      }
      
      const cardName = state.card?.name || 'a card';
      if (statusOverride) {
        statusElement.textContent = statusOverride;
      } else if (player === HUMAN) {
        const extra = isChainReaction ? 'Chain collapsed!' : 'Tile erased.';
        statusElement.textContent = `Player X unleashed ${cardName}! ${extra} Place your next mark.`;
      } else {
        statusElement.textContent = `AI used ${cardName} to destroy your tiles.`;
      }
      
      // Return animation duration if chain reaction, 0 otherwise
      // Chain reaction: TOTAL_DURATION (2500ms) for cascading + shake effect (2000ms) runs in parallel
      // Use 2500ms to ensure all animations complete
      return isChainReaction ? 2500 : 0;
    }

    function maybeAIDestroyTile() {
      if (!canUseDestroy(AI)) {
        aiCataclysmPending = false;
        return false;
      }
      
      // Check if there are valid targets BEFORE setting up the timeout
      let hasValidTarget = false;
      if (aiCataclysmPending) {
        const bestTarget = getBestCataclysmTarget();
        // AI can only use Cataclysm on X (HUMAN) tiles, never on O (AI) tiles
        if (bestTarget.index !== -1 && bestTarget.size >= 2 && board[bestTarget.index] === HUMAN) {
          hasValidTarget = true;
        } else {
          // No valid Cataclysm target, clear the pending flag
          aiCataclysmPending = false;
        }
      } else {
        // Check for single destroy target (Erasure/Ruin Pulse)
        // findHumanTileToDestroy now skips Fortress tiles
        const target = findHumanTileToDestroy();
        if (target !== -1) {
          hasValidTarget = true;
        } else {
          // No valid target found - check if all X tiles are Fortresses
          const allXTiles = board
            .map((cell, idx) => (cell === HUMAN ? idx : null))
            .filter(idx => idx !== null);
          const allAreFortresses = allXTiles.length > 0 && allXTiles.every(idx => isFortressTile(idx));
          if (allAreFortresses) {
            // All X tiles are Fortresses - can't destroy any, wait 3 seconds then proceed
            const state = playerState[AI];
            if (state) {
              state.destroyUsed = true;
            }
            updateDestroyTargetPulsation();
            statusElement.textContent = 'AI tried to use Erasure but all tiles are protected by Fortresses!';
            setTimeout(() => {
              if (!gameOver && currentPlayer === AI) {
                scheduleAIMove();
              }
            }, 3000);
            return true; // Indicates we're waiting (but not for destroy)
          }
        }
      }
      
      // If no valid targets, mark destroy as used and proceed with normal move
      if (!hasValidTarget) {
        const state = playerState[AI];
        if (state) {
          state.destroyUsed = true;
        }
        updateDestroyTargetPulsation();
        return false; // No destroy pending, proceed with normal move
      }
      
      // Update pulsation state (no pulsation for AI, only for human)
      updateDestroyTargetPulsation();
      
      // Wait 1.5 seconds before destroying
      setTimeout(() => {
        if (!canUseDestroy(AI) || gameOver || currentPlayer !== AI) {
          updateDestroyTargetPulsation();
          return;
        }
        if (aiCataclysmPending) {
          const bestTarget = getBestCataclysmTarget();
          // AI can only use Cataclysm on X (HUMAN) tiles, never on O (AI) tiles
          if (bestTarget.index !== -1 && bestTarget.size >= 2 && board[bestTarget.index] === HUMAN) {
            const cardName = playerState[AI].card?.name || 'an ability';
            aiCataclysmPending = false;
            const destroyResult = useDestroyAbility(AI, bestTarget.index, `AI unleashed ${cardName} to collapse your tiles.`);
            if (destroyResult !== false && !gameOver && currentPlayer === AI) {
              if (destroyResult > 0) {
                setTimeout(() => {
                  if (!gameOver && currentPlayer === AI) {
                    processTurnResult(AI);
                  }
                }, destroyResult);
              } else {
                processTurnResult(AI);
              }
            }
            return;
          }
          aiCataclysmPending = false;
        }
        const target = findHumanTileToDestroy();
        if (target === -1) {
          // No target found (shouldn't happen since we checked earlier, but handle it anyway)
          const state = playerState[AI];
          if (state) {
            state.destroyUsed = true;
          }
          updateDestroyTargetPulsation();
          // Proceed with normal move
          if (!gameOver && currentPlayer === AI) {
            scheduleAIMove();
          }
          return;
        }
        const cardName = playerState[AI].card?.name || 'an ability';
        const destroyResult = useDestroyAbility(AI, target, `AI activated ${cardName} to obliterate your tile.`);
        if (destroyResult === false) {
          // Destroy failed (likely because target is a Fortress tile)
          // Check if all X tiles are Fortresses
          const allXTiles = board
            .map((cell, idx) => (cell === HUMAN ? idx : null))
            .filter(idx => idx !== null);
          const allAreFortresses = allXTiles.length > 0 && allXTiles.every(idx => isFortressTile(idx));
          
          const state = playerState[AI];
          if (state) {
            state.destroyUsed = true;
          }
          updateDestroyTargetPulsation();
          
          if (allAreFortresses) {
            statusElement.textContent = 'AI tried to use Erasure but all tiles are protected by Fortresses!';
            // Wait 3 seconds then proceed with normal move
            setTimeout(() => {
              if (!gameOver && currentPlayer === AI) {
                scheduleAIMove();
              }
            }, 3000);
          } else {
            // Some X tiles might not be Fortresses, try to find another target
            // But for safety, just proceed with normal move after a short delay
            setTimeout(() => {
              if (!gameOver && currentPlayer === AI) {
                scheduleAIMove();
              }
            }, 1500);
          }
          return;
        }
        if (destroyResult !== false && !gameOver && currentPlayer === AI) {
          if (destroyResult > 0) {
            setTimeout(() => {
              if (!gameOver && currentPlayer === AI) {
                processTurnResult(AI);
              }
            }, destroyResult);
          } else {
            processTurnResult(AI);
          }
        }
      }, 1500);
      return true; // Indicates destroy is pending
    }

    function findHumanTileToDestroy() {
      let candidate = -1;
      let bestCount = 0;
      winningLines.forEach(line => {
        // Filter out Fortress tiles - they can't be destroyed
        const humanTiles = line.filter(idx => board[idx] === HUMAN && !isFortressTile(idx));
        const humanCount = humanTiles.length;
        const aiCount = line.filter(idx => board[idx] === AI).length;
        if (humanCount > 0 && aiCount === 0 && humanCount >= bestCount) {
          bestCount = humanCount;
          const tileIdx = humanTiles[0]; // Get first non-Fortress HUMAN tile
          if (tileIdx !== undefined) {
            candidate = tileIdx;
          }
        }
      });
      if (candidate !== -1) return candidate;
      // Fallback: find any non-Fortress HUMAN tile
      return board.findIndex((cell, idx) => cell === HUMAN && !isFortressTile(idx));
    }

    function getBestCataclysmTarget() {
      // AI can only use Cataclysm on X (HUMAN) tiles, never on O (AI) tiles
      // Also skip Fortress tiles - they can't be destroyed
      const visited = new Set();
      let bestSize = 0;
      let bestIndex = -1;
      for (let idx = 0; idx < board.length; idx++) {
        if (board[idx] === HUMAN && !isFortressTile(idx) && !visited.has(idx)) {
          const cluster = getConnectedCluster(idx, HUMAN);
          cluster.forEach(node => visited.add(node));
          if (cluster.length > bestSize) {
            bestSize = cluster.length;
            bestIndex = idx;
          }
        }
      }
      return { index: bestIndex, size: bestSize };
    }

    function getEmptyIndices(state, options = {}) {
      const includeMystery = Boolean(options.includeMystery);
      const includeGhosts = Boolean(options.includeGhosts);
      return state
        .map((cell, idx) => {
          if (cell) return null;
          if (!includeMystery && isMysteryTile(idx)) return null;
          if (!includeGhosts && isGhostTile(idx)) return null;
          return idx;
        })
        .filter(idx => idx !== null);
    }

    function getAllIndices() {
      return Array.from({ length: board.length }, (_, idx) => idx);
    }

    function getCornerIndices() {
      const topRight = boardSize - 1;
      const bottomLeft = board.length - boardSize;
      const bottomRight = board.length - 1;
      return [0, topRight, bottomLeft, bottomRight];
    }

    function getEdgeIndices() {
      const edges = [];
      const last = boardSize - 1;
      if (last < 1) return edges;
      for (let col = 1; col < last; col++) {
        edges.push(col);
        edges.push(last * boardSize + col);
      }
      for (let row = 1; row < last; row++) {
        edges.push(row * boardSize);
        edges.push(row * boardSize + last);
      }
      const cornerSet = new Set(getCornerIndices());
      return edges.filter(idx => !cornerSet.has(idx));
    }

    function getCenterIndices() {
      if (boardSize % 2 === 1) {
        const mid = Math.floor(boardSize / 2);
        return [mid * boardSize + mid];
      }
      const lower = boardSize / 2 - 1;
      const upper = boardSize / 2;
      return [
        lower * boardSize + lower,
        lower * boardSize + upper,
        upper * boardSize + lower,
        upper * boardSize + upper
      ];
    }

    function getPreferredIndices() {
      const pref = [...getCenterIndices(), ...getCornerIndices()];
      const unique = new Set(pref);
      for (let i = 0; i < board.length; i++) {
        unique.add(i);
      }
      return Array.from(unique);
    }

    function getConnectedCluster(startIdx, symbol) {
      if (!(symbol === HUMAN || symbol === AI)) return [];
      const visited = new Set();
      const cluster = [];
      const stack = [startIdx];
      while (stack.length) {
        const current = stack.pop();
        if (visited.has(current)) continue;
        if (board[current] !== symbol) continue;
        // Exclude fortress tiles from cluster (they can't be destroyed)
        if (isFortressTile(current)) continue;
        visited.add(current);
        cluster.push(current);
        getNeighborIndices(current).forEach(neighbor => {
          if (!visited.has(neighbor) && board[neighbor] === symbol && !isFortressTile(neighbor)) {
            stack.push(neighbor);
          }
        });
      }
      return cluster;
    }

    function getDistanceMap(startIdx, cluster) {
      const distances = new Map();
      const queue = [{ idx: startIdx, dist: 0 }];
      const visited = new Set([startIdx]);
      
      while (queue.length > 0) {
        const { idx, dist } = queue.shift();
        distances.set(idx, dist);
        
        getNeighborIndices(idx).forEach(neighbor => {
          if (cluster.includes(neighbor) && !visited.has(neighbor)) {
            visited.add(neighbor);
            queue.push({ idx: neighbor, dist: dist + 1 });
          }
        });
      }
      
      return distances;
    }

    function animateCascadingCataclysm(startIdx, cluster, symbol) {
      if (!cluster.length) return;
      
      const distanceMap = getDistanceMap(startIdx, cluster);
      const maxDistance = Math.max(...Array.from(distanceMap.values()));
      
      const TOTAL_DURATION = 2500;
      const FADE_DURATION = 800;
      
      cluster.forEach(targetIdx => {
        const btn = boardElement.children[targetIdx];
        const removedSymbol = board[targetIdx];
        
        board[targetIdx] = '';
        clearAmbushAt(targetIdx);
        
        if (btn) {
          // Immediately re-enable the tile since board state is cleared
          // This prevents tiles from appearing empty but being unclickable
          btn.disabled = false;
          btn.classList.remove('win', 'blocked');
          
          const distance = distanceMap.get(targetIdx) || 0;
          const delay = maxDistance > 0 
            ? (distance / maxDistance) * (TOTAL_DURATION - FADE_DURATION)
            : 0;
          
          setTimeout(() => {
            removeTileFadeOverlay(btn);
            btn.textContent = '';
            clearTileMark(btn);
            
            if (removedSymbol === HUMAN || removedSymbol === AI) {
              animateLetterFade(btn, removedSymbol, FADE_DURATION);
            }
          }, delay);
        }
      });
    }

    function getNeighborIndices(idx) {
      const neighbors = [];
      const row = Math.floor(idx / boardSize);
      const col = idx % boardSize;
      if (row > 0) neighbors.push(idx - boardSize);
      if (row < boardSize - 1) neighbors.push(idx + boardSize);
      if (col > 0) neighbors.push(idx - 1);
      if (col < boardSize - 1) neighbors.push(idx + 1);
      return neighbors;
    }

    function getEmmaBloomNeighbors(idx) {
      const neighbors = [];
      const row = Math.floor(idx / boardSize);
      const col = idx % boardSize;
      for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = row + dr;
          const nc = col + dc;
          if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) continue;
          neighbors.push(nr * boardSize + nc);
        }
      }
      return neighbors;
    }

    function getAmbushOwner(idx) {
      return ambushTraps.get(idx);
    }

    function isAmbushMarked(idx) {
      return ambushTraps.has(idx);
    }

    function renderAmbushTile(idx) {
      const tile = boardElement.children[idx];
      if (!tile) return;
      clearTilePreviewState(idx);
      tile.classList.add('ambush');
      tile.dataset.ambush = '1';
      const owner = ambushTraps.get(idx);
      if (owner === AI) {
        tile.classList.add('ai-ambush');
      } else {
        tile.classList.remove('ai-ambush');
      }
    }

    function placeAmbushTrap(player, idx) {
      if (board[idx] || isMysteryTile(idx)) return { success: false };
      
      // Check if there's already an opponent's ambush on this tile
      const existingAmbushOwner = getAmbushOwner(idx);
      if (existingAmbushOwner && existingAmbushOwner !== player) {
        // Double ambush! Trigger the opponent's ambush immediately
        // The victim is the player placing the ambush (their connected tiles get destroyed)
        clearAmbushAt(idx); // Clear the opponent's ambush
        triggerDoubleAmbush(idx, player, existingAmbushOwner);
        return { success: true, doubleAmbush: true };
      }
      
      // Can't place on own ambush
      if (isAmbushMarked(idx)) return { success: false };
      
      ambushTraps.set(idx, player);
      renderAmbushTile(idx);
      return { success: true, doubleAmbush: false };
    }

    function clearAmbushAt(idx) {
      if (!ambushTraps.has(idx)) return;
      ambushTraps.delete(idx);
      const tile = boardElement.children[idx];
      if (tile) {
        tile.classList.remove('ambush', 'ai-ambush');
        tile.removeAttribute('data-ambush');
      }
    }

    function attemptAmbushPlacement(player, idx) {
      const state = playerState[player];
      if (!state?.ambushArming) return;
      if (board[idx] || board[idx] === 'BLOCK' || isMysteryTile(idx)) {
        statusElement.textContent = 'Choose an empty tile for your ambush.';
        return;
      }
      // Allow placing on opponent's ambush (will trigger double ambush)
      // But not on own ambush
      const existingAmbushOwner = getAmbushOwner(idx);
      if (existingAmbushOwner === player) {
        statusElement.textContent = 'Choose an empty tile for your ambush.';
        return;
      }
      const result = placeAmbushTrap(player, idx);
      if (result && result.success) {
        state.ambushArming = false;
        state.ambushAvailable = false;
        if (result.doubleAmbush) {
          // Double ambush triggered - player's turn ends after effects
          state.ready = false;
          // Wait for double ambush animations to complete (2000ms for shake)
          setTimeout(() => {
            if (!gameOver) {
              evaluateBoardStateAfterAuto();
              if (!gameOver) {
                processTurnResult(player);
              }
            }
          }, 2000);
        } else {
          // Normal ambush placement
          if (!gameOver) {
            state.ready = true;
            statusElement.textContent = 'Ambush armed! Place your mark.';
          } else {
            statusElement.textContent = 'Ambush armed!';
          }
        }
      }
    }

    function resolveAmbushSpring(player, idx, owner) {
      // Check if this ambush can be triggered by this player
      // AI's ambush can only be triggered by HUMAN
      // HUMAN's ambush can only be triggered by AI
      const canTrigger = (owner === AI && player === HUMAN) || 
                        (owner === HUMAN && player === AI);
      if (!canTrigger) {
        // This player cannot trigger this ambush - just clear it and place the tile
        clearAmbushAt(idx);
        makeMove(idx, player, true); // Skip ambush check, we're handling it
        return;
      }
      
      // Check if there's a ghost on this tile that hasn't formed yet
      const ghost = ghostTiles.get(idx);
      if (ghost && ghost.turns < 3) {
        // Ghost hasn't formed yet, so ambush doesn't trigger
        // The ghost will trigger the ambush when it materializes
        makeMove(idx, player, true); // Skip ambush check, we're handling it
        // Mark that this ghost will trigger ambush when it forms
        ghost.ambushOwner = owner;
        finishAmbushTurn(player);
        return;
      }
      // No ghost or ghost is formed, trigger ambush normally
      makeMove(idx, player, true); // Skip ambush check, we're handling it
      triggerAmbush(idx, player, owner);
      finishAmbushTurn(player);
    }

    function triggerAmbush(idx, victim, owner) {
      ambushTraps.delete(idx);
      if (mysteryTileIndices.includes(idx)) {
        mysteryTileIndices = mysteryTileIndices.filter(i => i !== idx);
      }
      const tile = boardElement.children[idx];
      if (tile) {
        tile.classList.remove('ambush');
      }
      const cluster = getConnectedCluster(idx, victim);
      cluster.forEach(target => {
        const removedSymbol = board[target];
        board[target] = '';
        const cell = boardElement.children[target];
        if (cell) {
          cell.disabled = false;
          cell.classList.remove('win', 'blocked');
          clearTileMark(cell);
          removeTileFadeOverlay(cell);
          if (removedSymbol === HUMAN || removedSymbol === AI) {
            cell.textContent = '';
            animateLetterFade(cell, removedSymbol);
          } else {
            cell.textContent = '';
          }
        }
        clearAmbushAt(target);
      });
      playAmbushEffects();
      statusElement.textContent = `${playerLabel(owner)}'s ambush detonates! ${playerLabel(victim)} loses ${cluster.length} tiles.`;
    }

    function triggerDoubleAmbush(idx, victim, owner) {
      // Double ambush: victim is the player placing the ambush, owner is the original ambush owner
      if (mysteryTileIndices.includes(idx)) {
        mysteryTileIndices = mysteryTileIndices.filter(i => i !== idx);
      }
      const tile = boardElement.children[idx];
      if (tile) {
        tile.classList.remove('ambush', 'ai-ambush');
      }
      const cluster = getConnectedCluster(idx, victim);
      cluster.forEach(target => {
        const removedSymbol = board[target];
        board[target] = '';
        const cell = boardElement.children[target];
        if (cell) {
          cell.disabled = false;
          cell.classList.remove('win', 'blocked');
          clearTileMark(cell);
          removeTileFadeOverlay(cell);
          if (removedSymbol === HUMAN || removedSymbol === AI) {
            cell.textContent = '';
            animateLetterFade(cell, removedSymbol);
          } else {
            cell.textContent = '';
          }
        }
        clearAmbushAt(target);
      });
      playDoubleAmbushEffects();
      statusElement.textContent = `DOUBLE AMBUSH! ${playerLabel(owner)}'s ambush detonates! ${playerLabel(victim)} loses ${cluster.length} tiles.`;
    }

    function finishAmbushTurn(victim) {
      const state = playerState[victim];
      if (state) {
        state.ready = false;
        state.extraTurnUsed = true;
      }
      // Wait for ambush animations to complete (shake effect lasts 2000ms)
      setTimeout(() => {
        if (!gameOver) {
          switchTurns(victim);
        }
      }, 2000);
    }

    function playerLabel(player) {
      return player === HUMAN ? 'Player X' : 'AI';
    }

    function getConsumeMessage(player, card) {
      if (!card) return `${playerLabel(player)} completes their action.`;
      switch (card.effect) {
        case 'voidTile':
        case 'doubleVoid':
          return 'Curses unleashed! Passing turn...';
        case 'emmaBloom':
          return `${playerLabel(player)}'s Emma Bloom reshapes the battlefield.`;
        case 'switcharoo':
          return `${playerLabel(player)}'s Switcharoo resolves. Passing turn...`;
        case 'omfg':
          return `OMFG! The board has been inverted! Passing turn...`;
        default:
          return `${playerLabel(player)} completes ${card.name}. Passing turn...`;
      }
    }

    function generateWinningLines(size, condition) {
      const lines = [];
      const index = (row, col) => row * size + col;

      for (let row = 0; row < size; row++) {
        for (let col = 0; col <= size - condition; col++) {
          const line = [];
          for (let offset = 0; offset < condition; offset++) {
            line.push(index(row, col + offset));
          }
          lines.push(line);
        }
      }

      for (let col = 0; col < size; col++) {
        for (let row = 0; row <= size - condition; row++) {
          const line = [];
          for (let offset = 0; offset < condition; offset++) {
            line.push(index(row + offset, col));
          }
          lines.push(line);
        }
      }

      for (let row = 0; row <= size - condition; row++) {
        for (let col = 0; col <= size - condition; col++) {
          const line = [];
          for (let offset = 0; offset < condition; offset++) {
            line.push(index(row + offset, col + offset));
          }
          lines.push(line);
        }
      }

      for (let row = 0; row <= size - condition; row++) {
        for (let col = condition - 1; col < size; col++) {
          const line = [];
          for (let offset = 0; offset < condition; offset++) {
            line.push(index(row + offset, col - offset));
          }
          lines.push(line);
        }
      }

      return lines;
    }

    function getBoardSizeForRound(round) {
      const clamped = Math.max(1, Math.min(round, TOTAL_ROUNDS));
      return BASE_BOARD_SIZE + (clamped - 1);
    }

    function computeTileWeights(size) {
      const weights = [];
      for (let row = 0; row < size; row++) {
        for (let col = 0; col < size; col++) {
          const ring = Math.min(row, col, size - 1 - row, size - 1 - col);
          weights.push(ring + 1);
        }
      }
      return weights;
    }


    function showWinCelebration(winner) {
      winMessage.classList.remove('round-summary');
      winMessage.textContent = `Player ${winner} Wins!`;
      winOverlay.classList.remove('summary-mode');
      winOverlay.classList.add('show');
      document.body.classList.add('shake');
      setTimeout(() => document.body.classList.remove('shake'), 700);
      launchConfetti();
    }

    function hideWinCelebration() {
      if (roundSummaryTimeout) {
        clearTimeout(roundSummaryTimeout);
        roundSummaryTimeout = null;
      }
      winOverlay.classList.remove('show');
      winOverlay.classList.remove('summary-mode');
      document.body.classList.remove('shake');
      winMessage.classList.remove('round-summary');
      clearConfetti();
    }

    function launchConfetti() {
      clearConfetti();
      const colors = ['#ff3864', '#ffd300', '#2ba84a', '#00aaff', '#ffffff'];
      for (let i = 0; i < 80; i++) {
        const piece = document.createElement('span');
        piece.className = 'confetti';
        piece.style.left = `${Math.random() * 100}%`;
        piece.style.backgroundColor = colors[i % colors.length];
        piece.style.animationDuration = `${3 + Math.random() * 2}s`;
        piece.style.animationDelay = `${Math.random() * 0.5}s`;
        piece.style.setProperty('--x-move', `${Math.random() * 60 - 30}px`);
        confettiContainer.appendChild(piece);
      }
      setTimeout(clearConfetti, 5000);
    }

    function clearConfetti() {
      confettiContainer.innerHTML = '';
    }

    function prepareAmbushTrap(player) {
      const state = playerState[player];
      if (!state) return;
      state.ambushAvailable = true;
      if (player === HUMAN) {
        state.ambushArming = true;
        statusElement.textContent = 'Select an empty tile to set your ambush trap.';
      } else {
        state.ambushArming = false;
        const idx = chooseAmbushTileFor(player);
        if (idx === -1) {
          statusElement.textContent = 'AI tried to set an ambush but found no space.';
        } else {
          const result = placeAmbushTrap(player, idx);
          if (result && result.success) {
            if (result.doubleAmbush) {
              // Double ambush triggered - AI's turn ends after effects
              state.ready = false;
              // Wait for double ambush animations to complete (2000ms for shake)
              setTimeout(() => {
                if (!gameOver) {
                  evaluateBoardStateAfterAuto();
                  if (!gameOver) {
                    processTurnResult(player);
                  }
                }
              }, 2000);
            } else {
              statusElement.textContent = 'AI has seeded an ambush somewhere on the board!';
            }
          }
        }
        state.ambushAvailable = false;
      }
    }

    function chooseAmbushTileFor(player) {
      const empties = getEmptyIndices(board, { includeMystery: false })
        .filter(idx => !isAmbushMarked(idx));
      if (!empties.length) return -1;
      const targeted = empties.filter(idx =>
        getNeighborIndices(idx).some(neighbor => board[neighbor] === (player === HUMAN ? AI : HUMAN))
      );
      const pool = targeted.length ? targeted : empties;
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function playAmbushEffects() {
      if (ambushFlashElement) {
        ambushFlashElement.classList.add('show');
        if (ambushFlashTimeout) clearTimeout(ambushFlashTimeout);
        ambushFlashTimeout = setTimeout(() => {
          ambushFlashElement.classList.remove('show');
          ambushFlashTimeout = null;
        }, 1000);
      }
      if (ambushAlertElement) {
        ambushAlertElement.classList.add('show');
        if (ambushAlertTimeout) clearTimeout(ambushAlertTimeout);
        ambushAlertTimeout = setTimeout(() => {
          ambushAlertElement.classList.remove('show');
          ambushAlertTimeout = null;
        }, 1000);
      }
      document.body.classList.add('ambush-shake');
      if (ambushShakeTimeout) clearTimeout(ambushShakeTimeout);
      ambushShakeTimeout = setTimeout(() => {
        document.body.classList.remove('ambush-shake');
        ambushShakeTimeout = null;
      }, 2000);
    }

    function playDoubleAmbushEffects() {
      // Use the same flash and shake as regular ambush, but show double ambush alert
      if (ambushFlashElement) {
        ambushFlashElement.classList.add('show');
        if (ambushFlashTimeout) clearTimeout(ambushFlashTimeout);
        ambushFlashTimeout = setTimeout(() => {
          ambushFlashElement.classList.remove('show');
          ambushFlashTimeout = null;
        }, 1000);
      }
      if (doubleAmbushAlertElement) {
        doubleAmbushAlertElement.classList.add('show');
        if (doubleAmbushAlertTimeout) clearTimeout(doubleAmbushAlertTimeout);
        doubleAmbushAlertTimeout = setTimeout(() => {
          doubleAmbushAlertElement.classList.remove('show');
          doubleAmbushAlertTimeout = null;
        }, 1500);
      }
      document.body.classList.add('ambush-shake');
      if (ambushShakeTimeout) clearTimeout(ambushShakeTimeout);
      ambushShakeTimeout = setTimeout(() => {
        document.body.classList.remove('ambush-shake');
        ambushShakeTimeout = null;
      }, 2000);
    }

    function clearAmbushEffects() {
      if (ambushFlashTimeout) {
        clearTimeout(ambushFlashTimeout);
        ambushFlashTimeout = null;
      }
      if (ambushAlertTimeout) {
        clearTimeout(ambushAlertTimeout);
        ambushAlertTimeout = null;
      }
      if (ambushShakeTimeout) {
        clearTimeout(ambushShakeTimeout);
        ambushShakeTimeout = null;
      }
      if (doubleAmbushAlertTimeout) {
        clearTimeout(doubleAmbushAlertTimeout);
        doubleAmbushAlertTimeout = null;
      }
      ambushFlashElement?.classList.remove('show');
      ambushAlertElement?.classList.remove('show');
      doubleAmbushAlertElement?.classList.remove('show');
      document.body.classList.remove('ambush-shake');
    }

    function showChainReactionEffects() {
      if (chainFlashElement) {
        chainFlashElement.classList.add('show');
        if (chainFlashTimeout) clearTimeout(chainFlashTimeout);
        chainFlashTimeout = setTimeout(() => {
          chainFlashElement.classList.remove('show');
          chainFlashTimeout = null;
        }, 1000);
      }
      if (chainAlertElement) {
        chainAlertElement.classList.add('show');
        if (chainAlertTimeout) clearTimeout(chainAlertTimeout);
        chainAlertTimeout = setTimeout(() => {
          chainAlertElement.classList.remove('show');
          chainAlertTimeout = null;
        }, 1000);
      }
      document.body.classList.add('chain-shake');
      if (chainShakeTimeout) clearTimeout(chainShakeTimeout);
      chainShakeTimeout = setTimeout(() => {
        document.body.classList.remove('chain-shake');
        chainShakeTimeout = null;
      }, 2000);
    }

    function clearChainEffects() {
      if (chainFlashTimeout) {
        clearTimeout(chainFlashTimeout);
        chainFlashTimeout = null;
      }
      if (chainAlertTimeout) {
        clearTimeout(chainAlertTimeout);
        chainAlertTimeout = null;
      }
      if (chainShakeTimeout) {
        clearTimeout(chainShakeTimeout);
        chainShakeTimeout = null;
      }
      chainFlashElement?.classList.remove('show');
      chainAlertElement?.classList.remove('show');
      document.body.classList.remove('chain-shake');
    }

    function triggerGhosts(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      // Get all empty tiles (can include tiles with enemy ghosts that haven't formed)
      const availableTiles = getEmptyIndices(board, { includeMystery: false })
        .filter(idx => {
          // Can place on empty tiles or enemy ghosts that haven't formed yet
          const enemyGhost = ghostTiles.get(idx);
          if (enemyGhost && enemyGhost.owner !== player && enemyGhost.turns < 3) {
            return true; // Can overwrite enemy ghost
          }
          // Can't place on own ghost or formed ghost
          if (isGhostTile(idx)) return false;
          return true;
        });
      if (!availableTiles.length) {
        statusElement.textContent = 'No available tiles for ghosts.';
        return CARD_FLOW.CONTINUE;
      }
      // Automatically spawn 3 random ghosts
      const maxGhosts = Math.min(3, availableTiles.length);
      const selectedTiles = [];
      const tilesToChoose = [...availableTiles];
      for (let i = 0; i < maxGhosts; i++) {
        if (tilesToChoose.length === 0) break;
        const randomIdx = Math.floor(Math.random() * tilesToChoose.length);
        selectedTiles.push(tilesToChoose[randomIdx]);
        tilesToChoose.splice(randomIdx, 1);
      }
      selectedTiles.forEach(idx => {
        // Clear enemy ghost if present
        const enemyGhost = ghostTiles.get(idx);
        if (enemyGhost && enemyGhost.owner !== player) {
          clearGhostAt(idx);
        }
        placeGhost(player, idx);
      });
      statusElement.textContent = `${playerLabel(player)} spawned ${selectedTiles.length} ghost${selectedTiles.length !== 1 ? 's' : ''}!`;
      evaluateBoardStateAfterAuto();
      return CARD_FLOW.CONTINUE;
    }


    function placeGhost(player, idx) {
      if (board[idx] || isMysteryTile(idx)) return false;
      // Can place on enemy ghost (will overwrite) or empty tile
      // Can also place on ambush tile (ambush won't trigger until ghost materializes)
      const existingGhost = ghostTiles.get(idx);
      if (existingGhost && existingGhost.owner === player) return false; // Can't place on own ghost
      
      // Clear enemy ghost if present
      if (existingGhost && existingGhost.owner !== player) {
        clearGhostAt(idx);
      }
      
      ghostTiles.set(idx, { owner: player, turns: 0 });
      renderGhostTile(idx);
      return true;
    }

    function renderGhostTile(idx) {
      const ghost = ghostTiles.get(idx);
      if (!ghost) return;
      const tile = boardElement.children[idx];
      if (!tile) return;
      
      tile.classList.add('ghost');
      const turnClass = `ghost-turn-${Math.min(ghost.turns, 3)}`;
      tile.classList.remove('ghost-turn-0', 'ghost-turn-1', 'ghost-turn-2', 'ghost-turn-3');
      tile.classList.add(turnClass);
      
      // Remove existing ghost mark
      const existingMark = tile.querySelector('.ghost-mark');
      if (existingMark) {
        existingMark.remove();
      }
      
      // Visibility logic: opponent can't see your ghosts until they're opaque (turn 3)
      // Hide AI ghosts from human player until turn 3, show human ghosts always
      // When viewing as human: hide AI ghosts (turns < 3), show X ghosts always
      const shouldHide = ghost.owner === AI && ghost.turns < 3;
      
      if (shouldHide) {
        tile.classList.add('hidden-ghost');
        // Don't add ghost mark if hidden
      } else {
        tile.classList.remove('hidden-ghost');
        // Only add ghost mark if it should be visible
        const ghostMark = document.createElement('span');
        ghostMark.className = 'ghost-mark';
        ghostMark.textContent = ghost.owner;
        ghostMark.style.color = ghost.owner === HUMAN ? '#4fd4ff' : '#ff5c7d';
        tile.appendChild(ghostMark);
      }
    }

    function advanceGhostTurns(ghostOwner) {
      // Only advance ghosts owned by the specified player
      // Ghosts advance when the opponent takes a turn
      ghostTiles.forEach((ghost, idx) => {
        if (ghost.owner !== ghostOwner) return; // Only advance ghosts owned by ghostOwner
        
        ghost.turns++;
        renderGhostTile(idx);
        
        // If ghost becomes fully opaque (turn 3), convert to real tile
        if (ghost.turns >= 3 && !board[idx]) {
          const owner = ghost.owner;
          ghostTiles.delete(idx);
          const tile = boardElement.children[idx];
          if (tile) {
            tile.classList.remove('ghost', 'ghost-turn-0', 'ghost-turn-1', 'ghost-turn-2', 'ghost-turn-3', 'hidden-ghost');
            const ghostMark = tile.querySelector('.ghost-mark');
            if (ghostMark) {
              ghostMark.remove();
            }
          }
          // Place the tile first, then check for ambush
          makeMove(idx, owner, true); // Skip ambush check, we'll handle it manually
          const ambushTriggered = checkAndTriggerAmbush(idx, owner);
          if (ambushTriggered) {
            statusElement.textContent = `${playerLabel(owner)}'s ghost materializes and triggers an ambush!`;
          } else {
            statusElement.textContent = `${playerLabel(owner)}'s ghost materializes!`;
            evaluateBoardStateAfterAuto();
          }
        }
      });
    }

    function clearGhostAt(idx) {
      if (!ghostTiles.has(idx)) return;
      ghostTiles.delete(idx);
      const tile = boardElement.children[idx];
      if (tile) {
        tile.classList.remove('ghost', 'ghost-turn-0', 'ghost-turn-1', 'ghost-turn-2', 'ghost-turn-3', 'hidden-ghost');
        const ghostMark = tile.querySelector('.ghost-mark');
        if (ghostMark) {
          ghostMark.remove();
        }
      }
    }

    function isGhostTile(idx) {
      return ghostTiles.has(idx);
    }

    function getGhostOwner(idx) {
      const ghost = ghostTiles.get(idx);
      return ghost ? ghost.owner : null;
    }

    function showTileWeightPreview() {
      weightPreviewActive = true;
      mysteryTileIndices = [];
      const tiles = boardElement.children;
      board.forEach((cell, idx) => {
        const tile = tiles[idx];
        if (!tile) return;
        tile.classList.remove('mystery', 'fading');
        if (!cell) {
          const value = tileWeights[idx];
          // Remove any existing preview number
          const existingNumber = tile.querySelector('.preview-number');
          if (existingNumber) {
            existingNumber.remove();
          }
          // Create span for the number
          const numberSpan = document.createElement('span');
          numberSpan.className = 'preview-number';
          numberSpan.textContent = value != null ? String(value) : '';
          tile.textContent = '';
          tile.appendChild(numberSpan);
          tile.classList.add('preview');
          tile.dataset.preview = '1';
        }
      });
      if (previewTimeout) {
        clearTimeout(previewTimeout);
        previewTimeout = null;
      }
      // Start showing mystery tiles during the preview fade (after 1 second)
      setupMysteryTile();
      // After 1 second, start fading
      setTimeout(() => {
        [...boardElement.children].forEach((tile, idx) => {
          if (tile && tile.dataset.preview === '1' && !board[idx]) {
            tile.classList.add('fading');
          }
        });
      }, 1000);
      // After 1.75 seconds total (1s visible + 0.75s fade), remove completely
      previewTimeout = setTimeout(() => {
        endTileWeightPreview();
        previewTimeout = null;
      }, 1750);
    }

    function endTileWeightPreview() {
      if (!weightPreviewActive) return;
      weightPreviewActive = false;
      [...boardElement.children].forEach((tile, idx) => {
        if (!tile) return;
        if (tile.dataset.preview === '1' && !board[idx]) {
          const previewNumber = tile.querySelector('.preview-number');
          if (previewNumber) {
            previewNumber.remove();
          }
          tile.textContent = '';
        }
        tile.classList.remove('preview', 'fading');
        tile.removeAttribute('data-preview');
      });
    }

    function clearTilePreviewState(idx) {
      const tile = boardElement.children[idx];
      if (!tile) return;
      const previewNumber = tile.querySelector('.preview-number');
      if (previewNumber) {
        previewNumber.remove();
      }
      tile.classList.remove('preview', 'fading');
      tile.removeAttribute('data-preview');
    }

    function getMaxMysteryTiles() {
      if (currentRound <= 2) return 1;
      if (currentRound <= 4) return 2;
      if (currentRound <= 6) return 3;
      return 4; // Round 7
    }

    function setupMysteryTile() {
      mysteryTileIndices = [];
      const maxMystery = getMaxMysteryTiles();
      const available = getAllIndices().filter(idx => !board[idx]);
      if (!available.length) return;
      
      const numMystery = Math.random() < MYSTERY_CHANCE ? Math.min(maxMystery, available.length) : 0;
      if (numMystery === 0) return;
      
      // Shuffle available indices and take the first numMystery
      const shuffled = [...available].sort(() => Math.random() - 0.5);
      const selected = shuffled.slice(0, numMystery);
      
      // Show them sequentially during the preview fade
      const previewDuration = 3000;
      const startDelay = 1000; // Start appearing 1 second into preview
      const delayBetween = 400; // 400ms between each appearance
      
      selected.forEach((idx, i) => {
        setTimeout(() => {
          if (!board[idx]) {
            mysteryTileIndices.push(idx);
            const tile = boardElement.children[idx];
            if (tile) {
              clearTilePreviewState(idx);
              tile.textContent = '?';
              tile.classList.add('mystery');
            }
          }
        }, startDelay + (i * delayBetween));
      });
    }

    function isMysteryTile(idx) {
      return mysteryTileIndices.includes(idx) && idx !== -1 && !board[idx];
    }

    function resolveMysteryTile(player, idx) {
      if (!isMysteryTile(idx)) return false;
      const tile = boardElement.children[idx];
      const symbol = Math.random() < 0.5 ? HUMAN : AI;
      mysteryTileIndices = mysteryTileIndices.filter(i => i !== idx);
      // Use makeMove to place the tile (this will check for ambushes)
      makeMove(idx, symbol);
      if (tile) {
        tile.classList.remove('mystery');
      }
      statusElement.textContent = `${playerLabel(player)} gambled on the mystery tile... It reveals ${symbol}!`;
      return true;
    }

    function triggerFortress(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      const availableTiles = getEmptyIndices(board, { includeMystery: false });
      if (!availableTiles.length) {
        statusElement.textContent = 'No empty tiles available for Fortress.';
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.fortressArming = true;
        state.ready = false;
        statusElement.textContent = 'Select an empty tile to place your Fortress.';
        return CARD_FLOW.PENDING;
      }
      const target = chooseFortressTileFor(player, availableTiles);
      if (target === -1) {
        statusElement.textContent = 'AI tried to place a Fortress but found no space.';
        return CARD_FLOW.CONTINUE;
      }
      const result = placeFortress(player, target);
      if (result && result.hadAmbush) {
        const ambushOwnerLabel = result.ambushOwner === HUMAN ? 'Player X' : 'AI';
        statusElement.textContent = `AI placed a Fortress! Your Ambush was deactivated.`;
      } else {
        statusElement.textContent = 'AI has placed a Fortress!';
      }
      evaluateBoardStateAfterAuto();
      if (!gameOver) {
        state.ready = true;
        scheduleAIMove();
      }
      return CARD_FLOW.CONTINUE;
    }

    function attemptFortressPlacement(player, idx) {
      const state = playerState[player];
      if (!state?.fortressArming) return;
      if (board[idx] || board[idx] === 'BLOCK' || isMysteryTile(idx) || isGhostTile(idx)) {
        statusElement.textContent = 'Choose an empty tile for your Fortress.';
        return;
      }
      state.fortressArming = false;
      const result = placeFortress(player, idx);
      if (!gameOver) {
        state.ready = true;
        if (result && result.hadAmbush) {
          const ambushOwnerLabel = result.ambushOwner === HUMAN ? 'Player X' : 'AI';
          statusElement.textContent = `Fortress placed! ${ambushOwnerLabel}'s Ambush deactivated. Place your mark.`;
        } else {
          statusElement.textContent = 'Fortress placed! Place your mark.';
        }
      }
    }

    function placeFortress(player, idx) {
      if (board[idx] || isMysteryTile(idx) || isGhostTile(idx)) return false;
      // Clear ghost if present
      if (isGhostTile(idx)) {
        clearGhostAt(idx);
      }
      // Check if there's an ambush on this tile - Fortress deactivates it
      const hadAmbush = isAmbushMarked(idx);
      const ambushOwner = hadAmbush ? getAmbushOwner(idx) : null;
      if (hadAmbush) {
        clearAmbushAt(idx);
      }
      // Place the player's mark
      makeMove(idx, player);
      // Mark as fortress
      fortressTiles.add(idx);
      const tile = boardElement.children[idx];
      if (tile) {
        tile.classList.add('fortress');
      }
      evaluateBoardStateAfterAuto();
      return { success: true, hadAmbush, ambushOwner };
    }

    function chooseFortressTileFor(player, availableTiles) {
      if (!availableTiles.length) return -1;
      // Prefer strategic positions (center, corners, edges)
      const centers = getCenterIndices();
      const corners = getCornerIndices();
      const edges = getEdgeIndices();
      
      const strategic = availableTiles.filter(idx => 
        centers.includes(idx) || corners.includes(idx) || edges.includes(idx)
      );
      
      const pool = strategic.length ? strategic : availableTiles;
      return pool[Math.floor(Math.random() * pool.length)];
    }

    function isFortressTile(idx) {
      return fortressTiles.has(idx);
    }

    function triggerOMFG(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      // Get all hex tiles (BLOCK tiles)
      const hexTiles = board
        .map((cell, idx) => (cell === 'BLOCK' ? idx : null))
        .filter(idx => idx !== null);
      if (!hexTiles.length) {
        statusElement.textContent = 'No hex tiles available to trigger OMFG.';
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.omfgArming = true;
        state.ready = false;
        // Enable Hex tiles so they can be clicked
        enableHexTilesForOMFG();
        statusElement.textContent = 'Select a Hex tile to invert the board!';
        return CARD_FLOW.PENDING;
      }
      // AI automatically selects a random hex tile
      const target = hexTiles[Math.floor(Math.random() * hexTiles.length)];
      // Play pink flash effect on the selected tile
      const targetTile = boardElement.children[target];
      if (targetTile) {
        playOMFGFlash(targetTile);
      }
      executeOMFG(player, target);
      // OMFG consumes the turn - no manual placement
      // Note: Animation delay is handled in executeOMFG, but we need to delay processTurnResult
      state.ready = false;
      // Return a special value to indicate we need to wait for animation
      // We'll handle the delay in handleCardSelection
      return 'OMFG_ANIMATING';
    }

    function playOMFGFlash(tileElement) {
      if (!tileElement) return;
      
      // Get tile position and size
      const rect = tileElement.getBoundingClientRect();
      const tileSize = rect.width;
      const flashSize = tileSize; // Same size as tile
      
      // Create flash element
      const flash = document.createElement('div');
      flash.className = 'omfg-flash';
      flash.style.width = `${flashSize}px`;
      flash.style.height = `${flashSize}px`;
      flash.style.left = `${rect.left}px`;
      flash.style.top = `${rect.top}px`;
      
      document.body.appendChild(flash);
      
      // Show flash
      requestAnimationFrame(() => {
        flash.classList.add('show');
      });
      
      // Remove after animation
      setTimeout(() => {
        flash.classList.remove('show');
        setTimeout(() => {
          flash.remove();
        }, 150);
      }, 300);
    }

    function attemptOMFGSelection(player, idx) {
      const state = playerState[player];
      if (!state?.omfgArming) return;
      if (board[idx] !== 'BLOCK') {
        statusElement.textContent = 'Select a Hex tile to trigger OMFG.';
        return;
      }
      state.omfgArming = false;
      // Disable Hex tiles again after selection
      disableHexTilesAfterOMFG();
      // Play pink flash effect on the selected tile
      const selectedTile = boardElement.children[idx];
      if (selectedTile) {
        playOMFGFlash(selectedTile);
      }
      executeOMFG(player, idx);
      // OMFG consumes the turn - no manual placement
      // Wait for animation to complete (1 second) before processing turn result
      if (!gameOver) {
        state.ready = false;
        setTimeout(() => {
          if (!gameOver) {
            processTurnResult(player);
          }
        }, 1000);
      }
    }

    function enableHexTilesForOMFG() {
      // Enable all Hex tiles (BLOCK tiles) so they can be clicked for OMFG
      // Also add pulsation effect
      board.forEach((cell, idx) => {
        if (cell === 'BLOCK') {
          const tile = boardElement.children[idx];
          if (tile) {
            tile.disabled = false;
            tile.classList.add('pulsate');
          }
        }
      });
    }

    function disableHexTilesAfterOMFG() {
      // Disable all Hex tiles again after OMFG selection
      // Also remove pulsation effect
      board.forEach((cell, idx) => {
        if (cell === 'BLOCK') {
          const tile = boardElement.children[idx];
          if (tile) {
            tile.disabled = true;
            tile.classList.remove('pulsate');
          }
        }
      });
    }

    function getManhattanDistance(idx1, idx2) {
      const row1 = Math.floor(idx1 / boardSize);
      const col1 = idx1 % boardSize;
      const row2 = Math.floor(idx2 / boardSize);
      const col2 = idx2 % boardSize;
      return Math.abs(row1 - row2) + Math.abs(col1 - col2);
    }

    function getOMFGCascadeLayers(hexTileIdx) {
      // Use BFS to find tiles in waves/layers based on connection distance from hex tile
      const layers = [];
      const visited = new Set();
      const queue = [{ idx: hexTileIdx, layer: 0 }];
      visited.add(hexTileIdx);
      
      while (queue.length > 0) {
        const { idx, layer } = queue.shift();
        
        // Get neighbors of current tile
        const neighbors = getNeighborIndices(idx);
        
        neighbors.forEach(neighborIdx => {
          if (visited.has(neighborIdx)) return;
          visited.add(neighborIdx);
          
          // Only include tiles that need to be inverted (X or O, not fortresses)
          const cell = board[neighborIdx];
          if (cell === HUMAN || cell === AI) {
            if (!isFortressTile(neighborIdx)) {
              // Add to appropriate layer
              if (!layers[layer + 1]) {
                layers[layer + 1] = [];
              }
              layers[layer + 1].push({ idx: neighborIdx, cell });
            }
          }
          
          // Continue BFS regardless (to find all connected tiles)
          queue.push({ idx: neighborIdx, layer: layer + 1 });
        });
      }
      
      // Find any disconnected tiles (not reachable from hex tile)
      const disconnectedTiles = [];
      board.forEach((cell, idx) => {
        if (visited.has(idx)) return;
        if (cell === HUMAN || cell === AI) {
          if (!isFortressTile(idx)) {
            disconnectedTiles.push({ idx, cell });
          }
        }
      });
      
      // Add disconnected tiles to the last layer (or create a new layer if no layers exist)
      if (disconnectedTiles.length > 0) {
        const lastLayerIndex = layers.length > 0 ? layers.length : 0;
        if (!layers[lastLayerIndex]) {
          layers[lastLayerIndex] = [];
        }
        layers[lastLayerIndex].push(...disconnectedTiles);
      }
      
      return layers;
    }

    function executeOMFG(player, hexTileIdx) {
      // Get tiles organized in cascade layers (waves)
      const layers = getOMFGCascadeLayers(hexTileIdx);
      
      if (layers.length === 0) {
        statusElement.textContent = `${playerLabel(player)} activated OMFG! (No tiles to invert)`;
        evaluateBoardStateAfterAuto();
        return;
      }
      
      // Get hex tile position for distance calculations
      const hexTile = boardElement.children[hexTileIdx];
      if (!hexTile) return;
      const hexRect = hexTile.getBoundingClientRect();
      const hexSize = hexRect.width;
      const hexCenterX = hexRect.left + hexRect.width / 2;
      const hexCenterY = hexRect.top + hexRect.height / 2;
      
      // Get board bounds to calculate max outline radius
      const boardRect = boardElement.getBoundingClientRect();
      const maxDistLeft = hexCenterX - boardRect.left;
      const maxDistRight = boardRect.right - hexCenterX;
      const maxDistTop = hexCenterY - boardRect.top;
      const maxDistBottom = boardRect.bottom - hexCenterY;
      const maxDistX = Math.max(maxDistLeft, maxDistRight);
      const maxDistY = Math.max(maxDistTop, maxDistBottom);
      const maxDist = Math.max(maxDistX, maxDistY);
      
      // Outline starts at hexSize/2 radius and grows to maxDist radius
      const startRadius = hexSize / 2;
      const finalRadius = maxDist;
      const radiusRange = finalRadius - startRadius;
      
      const OUTLINE_DURATION = 1000; // 1 second for tile swapping
      
      // Collect all tiles with their distances from hex center
      const tilesWithDistances = [];
      layers.forEach(layer => {
        layer.forEach(({ idx, cell }) => {
          const tile = boardElement.children[idx];
          if (tile) {
            const tileRect = tile.getBoundingClientRect();
            const tileCenterX = tileRect.left + tileRect.width / 2;
            const tileCenterY = tileRect.top + tileRect.height / 2;
            const tileRadius = tileRect.width / 2;
            
            // Distance from hex center to tile center
            const distX = tileCenterX - hexCenterX;
            const distY = tileCenterY - hexCenterY;
            const distance = Math.sqrt(distX * distX + distY * distY);
            
            // The outline's edge reaches the tile center when outline radius = distance
            // Calculate when this happens: (distance - startRadius) / radiusRange * duration
            const radiusAtTile = distance;
            const delay = radiusRange > 0
              ? Math.max(0, ((radiusAtTile - startRadius) / radiusRange) * OUTLINE_DURATION)
              : 0;
            
            tilesWithDistances.push({ idx, cell, distance, delay });
          }
        });
      });
      
      // Sort by delay so tiles swap in order
      tilesWithDistances.sort((a, b) => a.delay - b.delay);
      
      // Animate tiles based on when the outline's edge passes their center
      tilesWithDistances.forEach(({ idx, cell, delay }) => {
        setTimeout(() => {
          // Invert the tile (as the outline's edge passes its center)
          const newSymbol = cell === HUMAN ? AI : HUMAN;
          board[idx] = newSymbol;
          
          // Update the visual representation
          const tile = boardElement.children[idx];
          if (tile) {
            // Play pink flash effect on this tile
            playOMFGFlash(tile);
            
            tile.textContent = newSymbol;
            applyTileMark(tile, newSymbol);
            // Add a brief flash effect
            tile.style.transition = 'transform 0.15s ease, box-shadow 0.15s ease';
            tile.style.transform = 'scale(1.1)';
            tile.style.boxShadow = '0 0 15px rgba(255, 20, 147, 0.8)';
            setTimeout(() => {
              tile.style.transform = '';
              tile.style.boxShadow = '';
            }, 150);
          }
        }, delay);
      });
      
      statusElement.textContent = `${playerLabel(player)} activated OMFG! The board is inverting...`;
      
      // After animation completes, check game state (use 1.5s for outline, but wait a bit more for all swaps)
      const maxDelay = tilesWithDistances.length > 0 
        ? Math.max(...tilesWithDistances.map(t => t.delay))
        : OUTLINE_DURATION;
      const totalWait = Math.max(OUTLINE_DURATION, maxDelay + 200); // Add small buffer
      
      setTimeout(() => {
        statusElement.textContent = `${playerLabel(player)} activated OMFG! The board has been inverted!`;
        evaluateBoardStateAfterAuto();
      }, totalWait);
    }

    let toenadoCircle = null;
    let toenadoAnimationId = null;
    let pulledOTiles = new Set();
    let toenadoCleanupTimeout = null;
    let attachedTiles = new Map(); // Map<idx, {element: HTMLElement, offsetX: number, offsetY: number}>

    function triggerToenado(player) {
      const state = playerState[player];
      if (!state) return CARD_FLOW.CONTINUE;
      const ownedTiles = getOwnedTileIndices(player);
      if (!ownedTiles.length) {
        statusElement.textContent = `${playerLabel(player)} has no tiles to launch Toenado from.`;
        return CARD_FLOW.CONTINUE;
      }
      if (player === HUMAN) {
        state.toenadoArming = true;
        state.ready = false;
        statusElement.textContent = 'Select one of your X tiles to launch Toenado.';
        return CARD_FLOW.PENDING;
      }
      // AI automatically selects a random owned O tile
      const target = ownedTiles[Math.floor(Math.random() * ownedTiles.length)];
      state.ready = false;
      executeToenado(player, target);
      // Return PENDING so handleCardSelection doesn't immediately schedule AI move
      return CARD_FLOW.PENDING;
    }

    function attemptToenadoSelection(player, idx) {
      const state = playerState[player];
      if (!state?.toenadoArming) return;
      if (board[idx] !== player) {
        const tileType = player === HUMAN ? 'X' : 'O';
        statusElement.textContent = `Select one of your ${tileType} tiles to launch Toenado.`;
        return;
      }
      state.toenadoArming = false;
      executeToenado(player, idx);
      if (!gameOver) {
        state.ready = false;
      }
    }

    function executeToenado(player, startIdx) {
      // Clean up any existing toenado
      cleanupToenado();
      
      const startTile = boardElement.children[startIdx];
      if (!startTile) return;
      
      // Get starting position
      const startRect = startTile.getBoundingClientRect();
      const startX = startRect.left + startRect.width / 2;
      const startY = startRect.top + startRect.height / 2;
      
      // Create the white circle
      toenadoCircle = document.createElement('div');
      toenadoCircle.className = 'toenado-circle';
      toenadoCircle.style.left = `${startX - 30}px`;
      toenadoCircle.style.top = `${startY - 30}px`;
      document.body.appendChild(toenadoCircle);
      
      // Show the circle
      requestAnimationFrame(() => {
        toenadoCircle.classList.add('active');
      });
      
      // Generate random path
      const boardRect = boardElement.getBoundingClientRect();
      const path = generateRandomPath(startX, startY, boardRect, 5000);
      
      // Track pulled opponent tiles
      pulledOTiles.clear();
      
      // Determine target symbol (opponent's tiles)
      const targetSymbol = player === HUMAN ? AI : HUMAN;
      
      // Animate the circle along the path
      const startTime = Date.now();
      const duration = 5000; // 5 seconds
      
      function animate() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        if (progress >= 1) {
          // Animation complete - disintegrate
          disintegrateToenado(player, targetSymbol);
          return;
        }
        
        // Use very gentle easing for smooth, slow movement
        // This creates a slow start and slow end with steady middle
        const easedProgress = progress * progress * (3 - 2 * progress); // Smoothstep function
        
        // Get current position from path with smooth interpolation
        const exactIndex = easedProgress * (path.length - 1);
        const pathIndex = Math.floor(exactIndex);
        const nextIndex = Math.min(pathIndex + 1, path.length - 1);
        const fraction = exactIndex - pathIndex;
        
        const currentPoint = path[pathIndex];
        const nextPoint = path[nextIndex];
        
        if (currentPoint && nextPoint) {
          // Interpolate between path points for ultra-smooth movement
          const x = currentPoint.x + (nextPoint.x - currentPoint.x) * fraction;
          const y = currentPoint.y + (nextPoint.y - currentPoint.y) * fraction;
          
          toenadoCircle.style.left = `${x - 30}px`;
          toenadoCircle.style.top = `${y - 30}px`;
          
          // Update attached tiles to orbit around the circle
          // Spin speed increases as progress approaches 1 (faster near the end)
          // Base speed increases exponentially: 1 rotation at start, 8+ rotations at end
          const baseSpinSpeed = 1; // rotations per 5 seconds at start
          const endSpinSpeed = 8; // rotations per 5 seconds at end
          // Use exponential increase for dramatic speedup
          const spinMultiplier = baseSpinSpeed + (endSpinSpeed - baseSpinSpeed) * (progress * progress * progress);
          
          attachedTiles.forEach((attached, idx) => {
            // Calculate total rotation for this tile (includes its random offset)
            const totalRotation = (spinMultiplier * progress * Math.PI * 2) + attached.rotationOffset;
            
            // Calculate orbital position
            const angle = attached.initialAngle + totalRotation;
            const attachedX = x + Math.cos(angle) * attached.orbitalRadius;
            const attachedY = y + Math.sin(angle) * attached.orbitalRadius;
            
            // Position the attached tile
            attached.element.style.left = `${attachedX - attached.halfSize}px`;
            attached.element.style.top = `${attachedY - attached.halfSize}px`;
            
            // Add rotation to the tile itself for spinning effect
            const tileRotation = totalRotation * 180 / Math.PI; // Convert to degrees
            attached.element.style.transform = `rotate(${tileRotation}deg)`;
          });
          
          // Check for collisions with opponent's tiles
          checkToenadoCollisions(x, y, targetSymbol);
        }
        
        toenadoAnimationId = requestAnimationFrame(animate);
      }
      
      animate();
      
      statusElement.textContent = `${playerLabel(player)} launched Toenado! It sweeps across the board...`;
    }

    function generateRandomPath(startX, startY, boardRect, duration) {
      const path = [];
      const numPoints = 200; // More points for smoother path
      const boardWidth = boardRect.width;
      const boardHeight = boardRect.height;
      const boardLeft = boardRect.left;
      const boardTop = boardRect.top;
      
      // Generate fewer waypoints for smoother curves
      const numWaypoints = 5;
      const waypoints = [];
      
      // First waypoint is the start position
      waypoints.push({ x: startX, y: startY });
      
      // Generate intermediate waypoints
      for (let i = 1; i < numWaypoints - 1; i++) {
        waypoints.push({
          x: boardLeft + Math.random() * boardWidth,
          y: boardTop + Math.random() * boardHeight
        });
      }
      
      // Last waypoint is near the end of the board
      waypoints.push({
        x: boardLeft + Math.random() * boardWidth,
        y: boardTop + Math.random() * boardHeight
      });
      
      // Create smooth path using cubic interpolation (Catmull-Rom spline)
      for (let i = 0; i < numPoints; i++) {
        const t = i / (numPoints - 1);
        const segmentIndex = Math.floor(t * (waypoints.length - 1));
        const localT = (t * (waypoints.length - 1)) % 1;
        
        // Clamp segment index
        const p0Index = Math.max(0, segmentIndex - 1);
        const p1Index = segmentIndex;
        const p2Index = Math.min(waypoints.length - 1, segmentIndex + 1);
        const p3Index = Math.min(waypoints.length - 1, segmentIndex + 2);
        
        const p0 = waypoints[p0Index];
        const p1 = waypoints[p1Index];
        const p2 = waypoints[p2Index];
        const p3 = waypoints[p3Index];
        
        // Cubic interpolation for smooth curves
        const t2 = localT * localT;
        const t3 = t2 * localT;
        
        const x = 0.5 * (
          (2 * p1.x) +
          (-p0.x + p2.x) * localT +
          (2 * p0.x - 5 * p1.x + 4 * p2.x - p3.x) * t2 +
          (-p0.x + 3 * p1.x - 3 * p2.x + p3.x) * t3
        );
        
        const y = 0.5 * (
          (2 * p1.y) +
          (-p0.y + p2.y) * localT +
          (2 * p0.y - 5 * p1.y + 4 * p2.y - p3.y) * t2 +
          (-p0.y + 3 * p1.y - 3 * p2.y + p3.y) * t3
        );
        
        // Clamp to board bounds
        path.push({
          x: Math.max(boardLeft, Math.min(boardLeft + boardWidth, x)),
          y: Math.max(boardTop, Math.min(boardTop + boardHeight, y))
        });
      }
      
      return path;
    }

    function checkToenadoCollisions(circleX, circleY, targetSymbol) {
      // Check each tile to see if the circle passes over the tile's center
      const circleRadius = 30; // Half of 60px circle
      
      board.forEach((cell, idx) => {
        if (cell !== targetSymbol) return; // Only check target opponent's tiles
        if (pulledOTiles.has(idx)) return; // Already pulled
        if (isFortressTile(idx)) return; // Can't pull fortresses
        if (isGhostTile(idx)) return; // Can't pull ghosts
        
        const tile = boardElement.children[idx];
        if (!tile) return;
        
        const tileRect = tile.getBoundingClientRect();
        const tileCenterX = tileRect.left + tileRect.width / 2;
        const tileCenterY = tileRect.top + tileRect.height / 2;
        
        // Check if circle overlaps tile center (distance from circle center to tile center)
        const dx = circleX - tileCenterX;
        const dy = circleY - tileCenterY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance <= circleRadius) {
          // Pull this opponent tile
          pullOTile(idx);
        }
      });
    }

    function pullOTile(idx) {
      if (pulledOTiles.has(idx)) return;
      
      pulledOTiles.add(idx);
      const tile = boardElement.children[idx];
      if (!tile) return;
      
      // Store the cell value before clearing
      const cell = board[idx];
      
      // Get tile position and symbol before clearing
      const tileRect = tile.getBoundingClientRect();
      const tileCenterX = tileRect.left + tileRect.width / 2;
      const tileCenterY = tileRect.top + tileRect.height / 2;
      
      // Get current circle position
      const circleRect = toenadoCircle.getBoundingClientRect();
      const circleCenterX = circleRect.left + circleRect.width / 2;
      const circleCenterY = circleRect.top + circleRect.height / 2;
      
      // Calculate initial angle from circle center to tile
      const dx = tileCenterX - circleCenterX;
      const dy = tileCenterY - circleCenterY;
      const initialAngle = Math.atan2(dy, dx);
      // Use a consistent orbital radius (slightly larger than circle)
      const orbitalRadius = 50;
      
      // Clear the original tile immediately
      board[idx] = '';
      tile.classList.remove('tile-pulled', 'x-mark', 'o-mark', 'win', 'blocked');
      tile.textContent = '';
      tile.disabled = false;
      clearTileMark(tile);
      removeTileFadeOverlay(tile);
      clearAmbushAt(idx);
      
      // Create attached tile element
      const attachedElement = document.createElement('div');
      attachedElement.className = 'tile-attached';
      
      if (cell === HUMAN) {
        attachedElement.classList.add('x-mark');
        attachedElement.textContent = 'X';
      } else if (cell === AI) {
        attachedElement.classList.add('o-mark');
        attachedElement.textContent = 'O';
      }
      
      // Use the tile's font size
      const tileFontSize = window.getComputedStyle(tile).fontSize || '36px';
      attachedElement.style.fontSize = tileFontSize;
      
      // Calculate size for centering
      const fontSizeNum = parseFloat(tileFontSize);
      const halfSize = fontSizeNum / 2;
      
      // Position it at the tile's location initially
      attachedElement.style.left = `${tileCenterX - halfSize}px`;
      attachedElement.style.top = `${tileCenterY - halfSize}px`;
      document.body.appendChild(attachedElement);
      
      // Store the attached element with orbital parameters
      attachedTiles.set(idx, {
        element: attachedElement,
        initialAngle: initialAngle,
        orbitalRadius: orbitalRadius,
        halfSize: halfSize,
        rotationOffset: Math.random() * Math.PI * 2 // Random starting rotation for variety
      });
    }

    function disintegrateToenado(player, targetSymbol) {
      if (!toenadoCircle) return;
      
      // Disintegrate the circle
      toenadoCircle.classList.add('disintegrating');
      
      // Get circle position for calculating fly-off directions
      const circleRect = toenadoCircle.getBoundingClientRect();
      const circleCenterX = circleRect.left + circleRect.width / 2;
      const circleCenterY = circleRect.top + circleRect.height / 2;
      
      // Get viewport dimensions for calculating fly-off distance
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const maxDistance = Math.max(viewportWidth, viewportHeight) * 1.5; // Fly far off screen
      
      // Make attached tiles fly off in random directions
      attachedTiles.forEach((attached, idx) => {
        // Get current position from the element
        const elementRect = attached.element.getBoundingClientRect();
        const currentX = elementRect.left + elementRect.width / 2;
        const currentY = elementRect.top + elementRect.height / 2;
        
        // Random angle for fly-off direction (0 to 2π)
        const flyAngle = Math.random() * Math.PI * 2;
        
        // Calculate destination (far off screen)
        const flyDistance = maxDistance;
        const flyX = currentX + Math.cos(flyAngle) * flyDistance;
        const flyY = currentY + Math.sin(flyAngle) * flyDistance;
        
        // Get current rotation from transform
        const currentTransform = attached.element.style.transform || 'rotate(0deg)';
        const currentRotationMatch = currentTransform.match(/rotate\(([^)]+)\)/);
        const currentRotation = currentRotationMatch ? parseFloat(currentRotationMatch[1]) : 0;
        
        // Calculate rotation for spinning effect as it flies (continue from current rotation)
        const spinRotations = 3 + Math.random() * 2; // 3-5 full rotations
        const finalRotation = currentRotation + (spinRotations * 360);
        
        // Animate flying off (slowed down by 33%)
        const flyDuration = 1064; // 0.8s * 1.33 = ~1.064s
        attached.element.style.transition = `left ${flyDuration}ms ease-out, top ${flyDuration}ms ease-out, opacity ${flyDuration}ms ease-out, transform ${flyDuration}ms ease-out`;
        attached.element.style.left = `${flyX - attached.halfSize}px`;
        attached.element.style.top = `${flyY - attached.halfSize}px`;
        attached.element.style.opacity = '0';
        attached.element.style.transform = `rotate(${finalRotation}deg) scale(0.5)`;
      });
      
      // Remove pulled opponent tiles and clean up after animation
      setTimeout(() => {
        const pulledCount = pulledOTiles.size;
        const targetLabel = targetSymbol === HUMAN ? 'X' : 'O';
        
        // Remove attached tile elements
        attachedTiles.forEach((attached) => {
          attached.element.remove();
        });
        attachedTiles.clear();
        
        pulledOTiles.forEach(idx => {
          // Clear the tile (already cleared when pulled, but ensure it's empty)
          board[idx] = '';
          const tile = boardElement.children[idx];
          if (tile) {
            tile.classList.remove('tile-pulled', 'x-mark', 'o-mark', 'win', 'blocked');
            tile.textContent = '';
            tile.disabled = false;
            clearTileMark(tile);
            removeTileFadeOverlay(tile);
            clearAmbushAt(idx);
          }
        });
        
        pulledOTiles.clear();
        
        // Clean up the circle
        cleanupToenado();
        
        // Check game state
        evaluateBoardStateAfterAuto();
        
        // Update status
        if (pulledCount > 0) {
          statusElement.textContent = `Toenado disintegrated, removing ${pulledCount} ${targetLabel} tile${pulledCount !== 1 ? 's' : ''}!`;
        } else {
          statusElement.textContent = 'Toenado disintegrated!';
        }
        
        // Continue turn after a brief delay
        setTimeout(() => {
          if (!gameOver) {
            const state = playerState[currentPlayer];
            if (state) {
              state.ready = true;
              if (currentPlayer === HUMAN) {
                statusElement.textContent = 'Toenado complete! Place your mark.';
              } else {
                scheduleAIMove();
              }
            }
          }
        }, 200);
      }, 1064); // Wait for fly-off animation to complete (slowed by 33%)
    }

    function cleanupToenado() {
      if (toenadoAnimationId !== null) {
        cancelAnimationFrame(toenadoAnimationId);
        toenadoAnimationId = null;
      }
      if (toenadoCleanupTimeout) {
        clearTimeout(toenadoCleanupTimeout);
        toenadoCleanupTimeout = null;
      }
      if (toenadoCircle) {
        toenadoCircle.remove();
        toenadoCircle = null;
      }
      // Remove all attached tiles
      attachedTiles.forEach((attached) => {
        attached.element.remove();
      });
      attachedTiles.clear();
      pulledOTiles.clear();
    }

    function attemptAIMysteryTile() {
      const availableMystery = mysteryTileIndices.filter(idx => !board[idx] && isMysteryTile(idx));
      if (!availableMystery.length) return false;
      const mysteryIdx = availableMystery[Math.floor(Math.random() * availableMystery.length)];
      const trapOwner = getAmbushOwner(mysteryIdx);
      if (trapOwner && trapOwner !== AI) {
        resolveAmbushSpring(AI, mysteryIdx, trapOwner);
        return true;
      }
      if (trapOwner === AI) {
        clearAmbushAt(mysteryIdx);
      }
      const otherMovesAvailable = getEmptyIndices(board).length > availableMystery.length;
      const shouldTake = !otherMovesAvailable || Math.random() < 0.35;
      if (!shouldTake) return false;
      resolveMysteryTile(AI, mysteryIdx);
      return true;
    }

    window.addEventListener('resize', updateTileScale);

    resetRound(true, { statusMessage: 'Round 1: Player X chooses Card' });
  </script>

</body>
</html>
